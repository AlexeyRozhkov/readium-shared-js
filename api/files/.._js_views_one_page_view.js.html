<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>../js/views/one_page_view.js - Readium SDK DOM Access Layer API</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="page-top-wrapper" >
        </br> </br>
    </div>
    <div class="yui3-g header">
        <div class="yui3-u-3-4" >
              
                 <h1 id="logo" style="vertical-align:center"><img src="../assets/css/logo.png" title="Readium SDK DOM Access Layer API">Readium SDK DOM Access Layer API</h1>
              
        </div>
        <div class="yui3-u-1-4 version" >
            <div id="version">
            <em>API Docs for: 0.16</em>
        </div>
        </div>
    </div>
    <div id="bd" class="yui3-g">
        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/ReadiumSDK.Models.BookmarkData.html">ReadiumSDK.Models.BookmarkData</a></li>
            
                <li><a href="../classes/ReadiumSDK.Models.CurrentPagesInfo.html">ReadiumSDK.Models.CurrentPagesInfo</a></li>
            
                <li><a href="../classes/ReadiumSDK.Models.Package.html">ReadiumSDK.Models.Package</a></li>
            
                <li><a href="../classes/ReadiumSDK.Models.PackageData.html">ReadiumSDK.Models.PackageData</a></li>
            
                <li><a href="../classes/ReadiumSDK.Models.Spine.html">ReadiumSDK.Models.Spine</a></li>
            
                <li><a href="../classes/ReadiumSDK.Models.SpineItem.html">ReadiumSDK.Models.SpineItem</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: ../js/views/one_page_view.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
//  Created by Boris Schneiderman.
//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.
//  
//  Redistribution and use in source and binary forms, with or without modification, 
//  are permitted provided that the following conditions are met:
//  1. Redistributions of source code must retain the above copyright notice, this 
//  list of conditions and the following disclaimer.
//  2. Redistributions in binary form must reproduce the above copyright notice, 
//  this list of conditions and the following disclaimer in the documentation and/or 
//  other materials provided with the distribution.
//  3. Neither the name of the organization nor the names of its contributors may be 
//  used to endorse or promote products derived from this software without specific 
//  prior written permission.
//  
//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND 
//  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
//  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
//  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
//  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
//  OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED 
//  OF THE POSSIBILITY OF SUCH DAMAGE.



/**
 * Renders one page of fixed layout spread
 *
 * @param options
 * @param classes
 * @param enableBookStyleOverrides
 * @constructor
 */
ReadiumSDK.Views.OnePageView = function(options, classes, enableBookStyleOverrides, reader){

    _.extend(this, Backbone.Events);

    var self = this;

    var _$epubHtml;
    var _$el;
    var _$iframe;
    var _currentSpineItem;
    var _spine = options.spine;
    var _iframeLoader = options.iframeLoader;
    var _bookStyles = options.bookStyles;

    var _$viewport = options.$viewport;
    
    var _isIframeLoaded = false;

    var _$scaler;

    var PageTransitionHandler = function(opts)
    {
        var PageTransition = function(begin, end)
        {
            this.begin = begin;
            this.end = end;
        };
        
        var _pageTransition_OPACITY = new PageTransition(
            function(scale, left, top, $el, meta_width, meta_height, pageSwitchDir)
            {
                $el.css(&quot;opacity&quot;, &quot;0&quot;);
            },
            function(scale, left, top, $el, meta_width, meta_height, pageSwitchDir)
            {
                $el.css(&quot;transform&quot;, &quot;none&quot;);

                ReadiumSDK.Helpers.CSSTransition($el, &quot;opacity 150ms ease-out&quot;);

                $el.css(&quot;opacity&quot;, &quot;1&quot;);
            }
        );
        
        var _pageTransition_TRANSLATE = new PageTransition(
            function(scale, left, top, $el, meta_width, meta_height, pageSwitchDir)
            {
                $el.css(&quot;opacity&quot;, &quot;0&quot;);
                
                var elWidth = Math.ceil(meta_width * scale);
                
                var initialLeft = elWidth * 0.8 * (pageSwitchDir === 2 ? 1 : -1);
                var move = ReadiumSDK.Helpers.CSSTransformString({left: Math.round(initialLeft), origin: &quot;50% 50% 0&quot;, enable3D: _enable3D});
                $el.css(move);
            },
            function(scale, left, top, $el, meta_width, meta_height, pageSwitchDir)
            {
                $el.css(&quot;opacity&quot;, &quot;1&quot;);
                
                ReadiumSDK.Helpers.CSSTransition($el, &quot;transform 150ms ease-out&quot;);

                $el.css(&quot;transform&quot;, &quot;none&quot;);
            }
        );
        
        var _pageTransition_ROTATE = new PageTransition(
            function(scale, left, top, $el, meta_width, meta_height, pageSwitchDir)
            {
                $el.css(&quot;opacity&quot;, &quot;0&quot;);

                var elWidth = Math.ceil(meta_width * scale);

                var initialLeft = elWidth * 1.7 * (pageSwitchDir === 2 ? 1 : -1);
                var trans = ReadiumSDK.Helpers.CSSTransformString({left: Math.round(initialLeft), angle: (pageSwitchDir === 2 ? -1 : 1) * 30, origin: &quot;50% 50% 0&quot;, enable3D: _enable3D}); //(pageSwitchDir === 2 ? &#x27;0% 0%&#x27; : &#x27;100% 0%&#x27;)
                $el.css(trans);
            },
            function(scale, left, top, $el, meta_width, meta_height, pageSwitchDir)
            {
                $el.css(&quot;opacity&quot;, &quot;1&quot;);
                
                ReadiumSDK.Helpers.CSSTransition($el, &quot;transform 300ms ease-in-out&quot;);
                
                $el.css(&quot;transform&quot;, &quot;none&quot;);
            }
        );
        
        var _pageTransition_SWING = new PageTransition(
            function(scale, left, top, $el, meta_width, meta_height, pageSwitchDir)
            {            
                $el.css(&quot;opacity&quot;, &quot;0&quot;);
                
                // SUPER HACKY!! (just for demo)
                var isLeft = false;
                var isCenter = false;
                var isRight = false;
                for (var i = 0; i &lt; classes.length; i++)
                {
                    var c = classes[i].toLowerCase();
                    if (c.indexOf(&quot;left&quot;) &gt;= 0)
                    {
                        isLeft = true;
                        break;
                    }
                    if (c.indexOf(&quot;right&quot;) &gt;= 0)
                    {
                        isRight = true;
                        break;
                    }
                    if (c.indexOf(&quot;center&quot;) &gt;= 0)
                    {
                        isCenter = true;
                        break;
                    }
                }
                
                var elWidth = Math.ceil(meta_width * scale);
                
                var initialLeft = elWidth * 0.5 * ((isLeft || isCenter &amp;&amp; pageSwitchDir === 1) ? 1 : -1);
                var trans = ReadiumSDK.Helpers.CSSTransformString({scale: 0.2, left: Math.round(initialLeft), angle: ((isLeft || isCenter &amp;&amp; pageSwitchDir === 1) ? 1 : -1) * 30, origin: &#x27;50% 50% 0&#x27;, enable3D: _enable3D});
                $el.css(trans);
            },
            function(scale, left, top, $el, meta_width, meta_height, pageSwitchDir)
            {
                $el.css(&quot;opacity&quot;, &quot;1&quot;);
                
                ReadiumSDK.Helpers.CSSTransition($el, &quot;transform 400ms ease-out&quot;);

                $el.css(&quot;transform&quot;, &quot;none&quot;);
            }
        );
        
        var _pageTransitions = [];
        _pageTransitions.push(_pageTransition_OPACITY); // 0
        _pageTransitions.push(_pageTransition_TRANSLATE); // 1
        _pageTransitions.push(_pageTransition_ROTATE); // 2
        _pageTransitions.push(_pageTransition_SWING); // 3
        
        var _disablePageTransitions = opts.disablePageTransitions || false;

        var _pageTransition = -1;

        var _enable3D = new ReadiumSDK.Models.ViewerSettings({}).enableGPUHardwareAccelerationCSS3D;
        
        var _viewerSettings = undefined;
        this.updateOptions = function(o)
        {
            _viewerSettings = o;
        
            var settings = _viewerSettings;
            if (!settings || typeof settings.enableGPUHardwareAccelerationCSS3D === &quot;undefined&quot;)
            {
                //defaults
                settings = new ReadiumSDK.Models.ViewerSettings({});
            }
            if (settings.enableGPUHardwareAccelerationCSS3D)
            {
                _enable3D = true;
            }
            
            if (o.pageTransition !== null &amp;&amp; typeof o.pageTransition !== &quot;undefined&quot;)
            {
                _pageTransition = o.pageTransition;
            }
        };
        this.updateOptions(opts);
        
        var _pageSwitchDir = 0;
        var _pageSwitchActuallyChanged = false;
        var _pageSwitchActuallyChanged_IFRAME_LOAD = false;

        // dir: 0 =&gt; new or same page, 1 =&gt; previous, 2 =&gt; next
        this.updatePageSwitchDir = function(dir, hasChanged)
        {
            if (_pageSwitchActuallyChanged_IFRAME_LOAD)
            {
                return;
            }
            
            _pageSwitchDir = dir;
            _pageSwitchActuallyChanged = hasChanged;
        };
        
        this.onIFrameLoad = function()
        {
            _pageSwitchActuallyChanged_IFRAME_LOAD = true; // second pass, but initial display for transition
        };
        
        this.transformContentImmediate_BEGIN = function($el, scale, left, top)
        {
            var pageSwitchActuallyChanged = _pageSwitchActuallyChanged || _pageSwitchActuallyChanged_IFRAME_LOAD;
            _pageSwitchActuallyChanged_IFRAME_LOAD = false;

            if (_disablePageTransitions || _pageTransition === -1) return;

            ReadiumSDK.Helpers.CSSTransition($el, &quot;all 0 ease 0&quot;);

            if (!pageSwitchActuallyChanged) return;

            var pageTransition = (_pageTransition &gt;= 0 &amp;&amp; _pageTransition &lt; _pageTransitions.length) ? _pageTransitions[_pageTransition] : undefined;

            if (_pageSwitchDir === 0 || !pageTransition)
            {
                $el.css(&quot;opacity&quot;, &quot;0&quot;);
            }
            else
            {
                pageTransition.begin(scale, left, top, $el, self.meta_width(), self.meta_height(), _pageSwitchDir);
            }
        };
        
        this.transformContentImmediate_END = function($el, scale, left, top)
        {
            if (_disablePageTransitions || _pageTransition === -1)
            {
                $el.css(&quot;transform&quot;, &quot;none&quot;);
                return;
            }
        
            setTimeout(function()
            {
                var pageTransition = (_pageTransition &gt;= 0 &amp;&amp; _pageTransition &lt; _pageTransitions.length) ? _pageTransitions[_pageTransition] : undefined;

                if (_pageSwitchDir === 0 || !pageTransition)
                {
                    $el.css(&quot;transform&quot;, &quot;none&quot;);
                    
                    ReadiumSDK.Helpers.CSSTransition($el, &quot;opacity 250ms linear&quot;);

                    $el.css(&quot;opacity&quot;, &quot;1&quot;);
                }
                else
                {
                    pageTransition.end(scale, left, top, $el, self.meta_width(), self.meta_height(), _pageSwitchDir);
                }

            }, 10);
        };  
    };
    var _pageTransitionHandler = new PageTransitionHandler(options);


    // fixed layout does not apply user styles to publisher content, but reflowable scroll view does
    var _enableBookStyleOverrides = enableBookStyleOverrides || false;

    var _meta_size = {
        width: 0,
        height: 0
    };
    
    this.element = function() {
        return _$el;
    };

    this.meta_height = function() {
        return _meta_size.height;
    };

    this.meta_width = function() {
        return _meta_size.width;
    };

    this.isDisplaying = function() {

        return _isIframeLoaded;
    };

    this.render = function() {

        var template = ReadiumSDK.Helpers.loadTemplate(&quot;single_page_frame&quot;, {});

        _$el = $(template);
        
        _$scaler = $(&quot;#scaler&quot;, _$el);

        ReadiumSDK.Helpers.CSSTransition(_$el, &quot;all 0 ease 0&quot;);
        
        _$el.css(&quot;transform&quot;, &quot;none&quot;);
    
        var settings = reader.viewerSettings();
        if (!settings || typeof settings.enableGPUHardwareAccelerationCSS3D === &quot;undefined&quot;)
        {
            //defaults
            settings = new ReadiumSDK.Models.ViewerSettings({});
        }
        if (settings.enableGPUHardwareAccelerationCSS3D) {

            // This fixes rendering issues with WebView (native apps), which crops content embedded in iframes unless GPU hardware acceleration is enabled for CSS rendering.
            _$el.css(&quot;transform&quot;, &quot;translateZ(0)&quot;);
        }
    
        _$el.css(&quot;height&quot;, &quot;100%&quot;);
        _$el.css(&quot;width&quot;, &quot;100%&quot;);

        for(var i = 0, count = classes.length; i &lt; count; i++) {
            _$el.addClass(classes[i]);
        }

        _$iframe = $(&quot;iframe&quot;, _$el);
    
        return this;
    };


    this.decorateIframe = function()
    {
        if (!_$iframe || !_$iframe.length) return;
        
        _$iframe.css(&quot;border-bottom&quot;, &quot;1px dashed silver&quot;);
        _$iframe.css(&quot;border-top&quot;, &quot;1px dashed silver&quot;);
    }
    
    this.remove = function() {
        _isIframeLoaded = false;
        _currentSpineItem = undefined;
        _$el.remove();
    };

    this.clear = function() {
        _isIframeLoaded = false;
        _$iframe[0].src = &quot;&quot;;
    };

    this.currentSpineItem = function() {

        return _currentSpineItem;
    };

    function onIFrameLoad(success) {

        if(success) {
            _isIframeLoaded = true;
            var epubContentDocument = _$iframe[0].contentDocument;
            _$epubHtml = $(&quot;html&quot;, epubContentDocument);
            if (!_$epubHtml || _$epubHtml.length == 0) {
                _$epubHtml = $(&quot;svg&quot;, epubContentDocument);
            }
            
            //_$epubHtml.css(&quot;overflow&quot;, &quot;hidden&quot;);

            if (_enableBookStyleOverrides) {
                self.applyBookStyles();
            }
            
            updateMetaSize();

            _pageTransitionHandler.onIFrameLoad();
        }
    }

    var _viewSettings = undefined;
    this.setViewSettings = function(settings) {
        
        _viewSettings = settings;

        if (_enableBookStyleOverrides) {
            self.applyBookStyles();
        }
        
        updateMetaSize();

        _pageTransitionHandler.updateOptions(settings);
    };

    function updateHtmlFontSize() {
        
        if (!_enableBookStyleOverrides) return;
        
        if(_$epubHtml &amp;&amp; _viewSettings) {
            ReadiumSDK.Helpers.UpdateHtmlFontSize(_$epubHtml, _viewSettings.fontSize);
        }
    }

    this.applyBookStyles = function() {
        
        if (!_enableBookStyleOverrides) return;
        
        if(_$epubHtml) {
            ReadiumSDK.Helpers.setStyles(_bookStyles.getStyles(), _$epubHtml);
            updateHtmlFontSize();
        }
    };

    //this is called by scroll_view for fixed spine item
    this.scaleToWidth = function(width) {

        if (_meta_size.width &lt;= 0) return; // resize event too early!

        var scale = width / _meta_size.width;
        self.transformContentImmediate(scale, 0, 0);
    };

    //this is called by scroll_view for reflowable spine item
    this.resizeIFrameToContent = function() {
        var contHeight = getContentDocHeight();
        //console.log(&quot;resizeIFrameToContent: &quot; + contHeight);

        self.setHeight(contHeight);

        self.showIFrame();
    };
    
    this.setHeight = function(height) {

        _$scaler.css(&quot;height&quot;, height + &quot;px&quot;);
        _$el.css(&quot;height&quot;, height + &quot;px&quot;);

//        _$iframe.css(&quot;height&quot;, height + &quot;px&quot;);
    };

    var _useCSSTransformToHideIframe = true;

    this.showIFrame = function() {

        _$iframe.css(&quot;visibility&quot;, &quot;visible&quot;);
        
        if (_useCSSTransformToHideIframe)
        {
            _$iframe.css(&quot;transform&quot;, &quot;none&quot;);

            var enable3D = false;
            var settings = _viewSettings;
            if (!settings || typeof settings.enableGPUHardwareAccelerationCSS3D === &quot;undefined&quot;)
            {
                //defaults
                settings = new ReadiumSDK.Models.ViewerSettings({});
            }
            if (settings.enableGPUHardwareAccelerationCSS3D)
            {
                enable3D = true;
                _$iframe.css(&quot;transform&quot;, &quot;translateZ(0)&quot;);
            }
        }
        else
        {
            _$iframe.css({left: &quot;0px&quot;, top: &quot;0px&quot;});
        }
    };

    this.hideIFrame = function() {

        _$iframe.css(&quot;visibility&quot;, &quot;hidden&quot;);
        
        // With some books, despite the iframe and its containing div wrapper being hidden,
        // the iframe&#x27;s contentWindow / contentDocument is still visible!
        // Thus why we translate the iframe out of view instead.
        
        if (_useCSSTransformToHideIframe)
        {
            var enable3D = false;
            var settings = _viewSettings;
            if (!settings || typeof settings.enableGPUHardwareAccelerationCSS3D === &quot;undefined&quot;)
            {
                //defaults
                settings = new ReadiumSDK.Models.ViewerSettings({});
            }
            if (settings.enableGPUHardwareAccelerationCSS3D)
            {
                enable3D = true;
            }

            var css = ReadiumSDK.Helpers.CSSTransformString({left: &quot;10000&quot;, top: &quot;10000&quot;, enable3D: enable3D});
            _$iframe.css(css);
        }
        else
        {
            _$iframe.css({left: &quot;10000px&quot;, top: &quot;10000px&quot;});
        }
    };

    function getContentDocHeight(){

        if(!_$iframe || !_$iframe.length) {
            return 0;
        }
        
        if (ReadiumSDK.Helpers.isIframeAlive(_$iframe[0]))
        {
            var win = _$iframe[0].contentWindow;
            var doc = _$iframe[0].contentDocument;
            
            var height = Math.round(parseFloat(win.getComputedStyle(doc.documentElement).height)); //body can be shorter!
            return height;
        }
        else if (_$epubHtml)
        {
            console.error(&quot;getContentDocHeight ??&quot;);
            
            var jqueryHeight = _$epubHtml.height();
            return jqueryHeight;
        }

        return 0;
    }

    // dir: 0 =&gt; new or same page, 1 =&gt; previous, 2 =&gt; next
    this.updatePageSwitchDir = function(dir, hasChanged)
    {
        _pageTransitionHandler.updatePageSwitchDir(dir, hasChanged);
    };
    

    this.transformContentImmediate = function(scale, left, top) {

        var elWidth = Math.ceil(_meta_size.width * scale);
        var elHeight = Math.floor(_meta_size.height * scale);

        _pageTransitionHandler.transformContentImmediate_BEGIN(_$el, scale, left, top);

        _$el.css(&quot;left&quot;, left + &quot;px&quot;);
        _$el.css(&quot;top&quot;, top + &quot;px&quot;);
        _$el.css(&quot;width&quot;, elWidth + &quot;px&quot;);
        _$el.css(&quot;height&quot;, elHeight + &quot;px&quot;);

        if(!_$epubHtml) {
//            debugger;
            return;
        }
    
        var enable3D = false;
        var settings = _viewSettings;
        if (!settings || typeof settings.enableGPUHardwareAccelerationCSS3D === &quot;undefined&quot;)
        {
            //defaults
            settings = new ReadiumSDK.Models.ViewerSettings({});
        }
        if (settings.enableGPUHardwareAccelerationCSS3D)
        {
            enable3D = true;
        }

        if (reader.needsFixedLayoutScalerWorkAround())
        {
            var css1 = ReadiumSDK.Helpers.CSSTransformString({scale : scale, enable3D: enable3D});
            _$epubHtml.css(css1);

            var css2 = ReadiumSDK.Helpers.CSSTransformString({scale : 1, enable3D: enable3D});
            css2[&quot;width&quot;] = _meta_size.width;
            css2[&quot;height&quot;] = _meta_size.height;
            _$scaler.css(css2);
        }
        else
        {
            var css = ReadiumSDK.Helpers.CSSTransformString({scale : scale, enable3D: enable3D});
            css[&quot;width&quot;] = _meta_size.width;
            css[&quot;height&quot;] = _meta_size.height;
            _$scaler.css(css);
        }

        // Chrome workaround: otherwise text is sometimes invisible (probably a rendering glitch due to the 3D transform graphics backend?)
        //_$epubHtml.css(&quot;visibility&quot;, &quot;hidden&quot;); // &quot;flashing&quot; in two-page spread mode is annoying :(
        _$epubHtml.css(&quot;opacity&quot;, &quot;0.999&quot;);

        self.showIFrame();
                
        setTimeout(function()
        {
            //_$epubHtml.css(&quot;visibility&quot;, &quot;visible&quot;);
            _$epubHtml.css(&quot;opacity&quot;, &quot;1&quot;);
        }, 0);

        _pageTransitionHandler.transformContentImmediate_END(_$el, scale, left, top);
    };

    this.getCalculatedPageHeight = function() {
        return _$el.height();
    };

    this.transformContent = _.bind(_.debounce(this.transformContentImmediate, 50), self);

    function updateMetaSize() {

        _meta_size.width = 0;
        _meta_size.height = 0;

        var size = undefined;

        var contentDocument = _$iframe[0].contentDocument;

        // first try to read viewport size
        var content = $(&#x27;meta[name=viewport]&#x27;, contentDocument).attr(&quot;content&quot;);

        // if not found try viewbox (used for SVG)
        if(!content) {
            content = $(&#x27;meta[name=viewbox]&#x27;, contentDocument).attr(&quot;content&quot;);
        }

        if(content) {
            size = parseMetaSize(content);
        }
        
        if (!size) {
            // TODO: the picked SVG element may be the root...may be deep inside the markup!
            var $svg = $(contentDocument).find(&#x27;svg&#x27;);
            //var $svg = $(contentDocument.documentElement);
            // contentDocument.documentElement.nodeName == &quot;svg&quot;
            if($svg.length &gt; 0) {

                var width = undefined;
                var height = undefined;
                
                var wAttr = $svg[0].getAttribute(&quot;width&quot;);
                if (wAttr) {
                    try {
                        width = parseInt(wAttr, 10);
                    }
                    catch (err)
                    {}
                }
                var hAttr = $svg[0].getAttribute(&quot;height&quot;);
                if (hAttr) {
                    try {
                        height = parseInt(hAttr, 10);
                    }
                    catch (err)
                    {}
                }

                if (width &amp;&amp; height)
                {
                    size = {
                        width: width,
                        height: height
                    }
                }
                else
                {
                    /// DISABLED (not a satisfactory fallback)
                    // content = $svg.attr(&#x27;viewBox&#x27;);
                    // if(content) {
                    //     size = parseViewBoxSize(content);
                    // }
                    //
                    // if (size) {
                    //     console.warn(&quot;Viewport SVG: using viewbox!&quot;);
                    // }
                }
            }
        }

        if(!size &amp;&amp; _currentSpineItem) {
            content = _currentSpineItem.getRenditionViewport();

            if(content) {
                size = parseMetaSize(content);
                if (size) {
                    console.log(&quot;Viewport: using rendition:viewport dimensions&quot;);
                }
            }
        }
        
        if (!size) {
            // Image fallback (auto-generated HTML template when WebView / iFrame is fed with image media type)
            var $img = $(contentDocument).find(&#x27;img&#x27;);
            if($img.length &gt; 0) {
                size = {
                    width: $img.width(),
                    height: $img.height()
                }
                // if (contentDocument &amp;&amp; contentDocument.documentElement &amp;&amp; contentDocument.documentElement.nodeName &amp;&amp; contentDocument.documentElement.nodeName.toLowerCase() == &quot;svg&quot;) {
                //     contentDocument.documentElement.setAttribute(&quot;width&quot;, size.width);
                //     contentDocument.documentElement.setAttribute(&quot;height&quot;, size.height);
                // }

                var isImage = _currentSpineItem &amp;&amp; _currentSpineItem.media_type &amp;&amp; _currentSpineItem.media_type.length &amp;&amp; _currentSpineItem.media_type.indexOf(&quot;image/&quot;) == 0;
                if (!isImage) {
                    console.warn(&quot;Viewport: using img dimensions!&quot;);
                }
            }
            else {
                $img = $(contentDocument).find(&#x27;image&#x27;);
                if($img.length &gt; 0) {
                    var width = undefined;
                    var height = undefined;
                
                    var wAttr = $img[0].getAttribute(&quot;width&quot;);
                    if (wAttr) {
                        try {
                            width = parseInt(wAttr, 10);
                        }
                        catch (err)
                        {}
                    }
                    var hAttr = $img[0].getAttribute(&quot;height&quot;);
                    if (hAttr) {
                        try {
                            height = parseInt(hAttr, 10);
                        }
                        catch (err)
                        {}
                    }

                    if (width &amp;&amp; height)
                    {
                        size = {
                            width: width,
                            height: height
                        }

                        // if (contentDocument &amp;&amp; contentDocument.documentElement &amp;&amp; contentDocument.documentElement.nodeName &amp;&amp; contentDocument.documentElement.nodeName.toLowerCase() == &quot;svg&quot;) {
                        //     contentDocument.documentElement.setAttribute(&quot;width&quot;, size.width);
                        //     contentDocument.documentElement.setAttribute(&quot;height&quot;, size.height);
                        // }

                        console.warn(&quot;Viewport: using image dimensions!&quot;);
                    }
                }
            }
        }
        
        if (!size) {
            // Not a great fallback, as it has the aspect ratio of the full window, but it is better than no display at all.
            width = _$viewport.width();
            height = _$viewport.height();
            size = {
                width: width,
                height: height
            }

            console.warn(&quot;Viewport: using browser / e-reader viewport dimensions!&quot;);
        }
        
        if(size) {
            _meta_size.width = size.width;
            _meta_size.height = size.height;
        }
    }

    //expected callback signature: function(success, $iframe, spineItem, isNewlyLoaded, context)
    this.loadSpineItem = function(spineItem, callback, context) {

        if(_currentSpineItem != spineItem) {

            _currentSpineItem = spineItem;
            var src = _spine.package.resolveRelativeUrl(spineItem.href);

            //if (spineItem &amp;&amp; spineItem.isFixedLayout())
            if (true) // both fixed layout and reflowable documents need hiding due to flashing during layout/rendering
            {
                //hide iframe until content is scaled
                self.hideIFrame();
            }
            
            self.trigger(ReadiumSDK.Views.OnePageView.SPINE_ITEM_OPEN_START, _$iframe, _currentSpineItem);
            _iframeLoader.loadIframe(_$iframe[0], src, function(success){

                if(success &amp;&amp; callback)
                {
                    var func = function() {
                        callback(success, _$iframe, _currentSpineItem, true, context);
                    };
                    
                    if (ReadiumSDK.Helpers.isIframeAlive(_$iframe[0]))
                    {
                        onIFrameLoad(success); // applies styles
                        
                        func();
                    }
                    else
                    {
                        console.error(&quot;onIFrameLoad !! doc &amp;&amp; win + TIMEOUT&quot;);
                        console.debug(spineItem.href);
                        
                        onIFrameLoad(success);
                        
                        setTimeout(func, 500);
                    }
                }
                else
                {
                    onIFrameLoad(success);
                }
                
            }, self, {spineItem: _currentSpineItem});
        }
        else
        {
            if(callback) {
                callback(true, _$iframe, _currentSpineItem, false, context);
            }
        }
    };
    //
    // function parseViewBoxSize(viewBoxString) {
    //
    //     var parts = viewBoxString.split(&#x27; &#x27;);
    //
    //     if(parts.length &lt; 4) {
    //         console.warn(viewBoxString + &quot; value is not valid viewBox size&quot;)
    //         return undefined;
    //     }
    //
    //     var width = parseInt(parts[2]);
    //     var height = parseInt(parts[3]);
    //
    //     if(!isNaN(width) &amp;&amp; !isNaN(height)) {
    //         return { width: width, height: height} ;
    //     }
    //
    //     return undefined;
    // }

    function parseMetaSize(content) {

        var pairs = content.replace(/\s/g, &#x27;&#x27;).split(&quot;,&quot;);

        var dict = {};

        for(var i = 0;  i  &lt; pairs.length; i++) {
            var nameVal = pairs[i].split(&quot;=&quot;);
            if(nameVal.length == 2) {

                dict[nameVal[0]] = nameVal[1];
            }
        }

        var width = Number.NaN;
        var height = Number.NaN;

        if(dict[&quot;width&quot;]) {
            width = parseInt(dict[&quot;width&quot;]);
        }

        if(dict[&quot;height&quot;]) {
            height = parseInt(dict[&quot;height&quot;]);
        }

        if(!isNaN(width) &amp;&amp; !isNaN(height)) {
            return { width: width, height: height} ;
        }

        return undefined;
    }

    this.getFirstVisibleElementCfi = function(){

        var navigation = new ReadiumSDK.Views.CfiNavigationLogic(_$el, _$iframe);
        return navigation.getFirstVisibleElementCfi(0);

    };

    this.getNavigator = function() {

        return new ReadiumSDK.Views.CfiNavigationLogic(_$el, _$iframe);
    };

    this.getElementByCfi = function(spineItem, cfi, classBlacklist, elementBlacklist, idBlacklist) {

        if(spineItem != _currentSpineItem) {
            console.error(&quot;spine item is not loaded&quot;);
            return undefined;
        }

        var navigation = new ReadiumSDK.Views.CfiNavigationLogic(_$el, _$iframe);
        return navigation.getElementByCfi(cfi, classBlacklist, elementBlacklist, idBlacklist);
    };

    this.getElementById = function(spineItem, id) {

        if(spineItem != _currentSpineItem) {
            console.error(&quot;spine item is not loaded&quot;);
            return undefined;
        }

        var navigation = new ReadiumSDK.Views.CfiNavigationLogic(_$el, _$iframe);
        return navigation.getElementById(id);
    };

    this.getElement = function(spineItem, selector) {

        if(spineItem != _currentSpineItem) {
            console.error(&quot;spine item is not loaded&quot;);
            return undefined;
        }

        var navigation = new ReadiumSDK.Views.CfiNavigationLogic(_$el, _$iframe);
        return navigation.getElement(selector);
    };

    this.getFirstVisibleMediaOverlayElement = function() {
        var navigation = new ReadiumSDK.Views.CfiNavigationLogic(_$el, _$iframe);
        return navigation.getFirstVisibleMediaOverlayElement({top:0, bottom: _$iframe.height()});
    };

    this.offset = function()
    {
        if (_$iframe)
        {
            return _$iframe.offset();
        }
        return undefined;
    }
};

ReadiumSDK.Views.OnePageView.SPINE_ITEM_OPEN_START = &quot;SpineItemOpenStart&quot;;

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
