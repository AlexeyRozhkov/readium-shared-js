{
  "version": 3,
  "file": "readium-plugin-annotations.js",
  "sources": [
    "backbone.js",
    "../../plugins/annotations/annotations_module.js",
    "../../plugins/annotations/annotations_manager.js",
    "../../plugins/annotations/main.js",
    "readium-plugin-annotations.js"
  ],
  "names": [],
  "mappings": "AAAA;AACA;ACDA,ADEA;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvoDA,ADwoDA;ACvoDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACvPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "sourcesContent": [
    "(function(t,e){if(typeof define===\"function\"&&define.amd){define('backbone',[\"underscore\",\"jquery\",\"exports\"],function(i,r,s){t.Backbone=e(t,s,i,r)})}else if(typeof exports!==\"undefined\"){var i=require(\"underscore\");e(t,exports,i)}else{t.Backbone=e(t,{},t._,t.jQuery||t.Zepto||t.ender||t.$)}})(this,function(t,e,i,r){var s=t.Backbone;var n=[];var a=n.push;var o=n.slice;var h=n.splice;e.VERSION=\"1.1.2\";e.$=r;e.noConflict=function(){t.Backbone=s;return this};e.emulateHTTP=false;e.emulateJSON=false;var u=e.Events={on:function(t,e,i){if(!c(this,\"on\",t,[e,i])||!e)return this;this._events||(this._events={});var r=this._events[t]||(this._events[t]=[]);r.push({callback:e,context:i,ctx:i||this});return this},once:function(t,e,r){if(!c(this,\"once\",t,[e,r])||!e)return this;var s=this;var n=i.once(function(){s.off(t,n);e.apply(this,arguments)});n._callback=e;return this.on(t,n,r)},off:function(t,e,r){var s,n,a,o,h,u,l,f;if(!this._events||!c(this,\"off\",t,[e,r]))return this;if(!t&&!e&&!r){this._events=void 0;return this}o=t?[t]:i.keys(this._events);for(h=0,u=o.length;h<u;h++){t=o[h];if(a=this._events[t]){this._events[t]=s=[];if(e||r){for(l=0,f=a.length;l<f;l++){n=a[l];if(e&&e!==n.callback&&e!==n.callback._callback||r&&r!==n.context){s.push(n)}}}if(!s.length)delete this._events[t]}}return this},trigger:function(t){if(!this._events)return this;var e=o.call(arguments,1);if(!c(this,\"trigger\",t,e))return this;var i=this._events[t];var r=this._events.all;if(i)f(i,e);if(r)f(r,arguments);return this},stopListening:function(t,e,r){var s=this._listeningTo;if(!s)return this;var n=!e&&!r;if(!r&&typeof e===\"object\")r=this;if(t)(s={})[t._listenId]=t;for(var a in s){t=s[a];t.off(e,r,this);if(n||i.isEmpty(t._events))delete this._listeningTo[a]}return this}};var l=/\\s+/;var c=function(t,e,i,r){if(!i)return true;if(typeof i===\"object\"){for(var s in i){t[e].apply(t,[s,i[s]].concat(r))}return false}if(l.test(i)){var n=i.split(l);for(var a=0,o=n.length;a<o;a++){t[e].apply(t,[n[a]].concat(r))}return false}return true};var f=function(t,e){var i,r=-1,s=t.length,n=e[0],a=e[1],o=e[2];switch(e.length){case 0:while(++r<s)(i=t[r]).callback.call(i.ctx);return;case 1:while(++r<s)(i=t[r]).callback.call(i.ctx,n);return;case 2:while(++r<s)(i=t[r]).callback.call(i.ctx,n,a);return;case 3:while(++r<s)(i=t[r]).callback.call(i.ctx,n,a,o);return;default:while(++r<s)(i=t[r]).callback.apply(i.ctx,e);return}};var d={listenTo:\"on\",listenToOnce:\"once\"};i.each(d,function(t,e){u[e]=function(e,r,s){var n=this._listeningTo||(this._listeningTo={});var a=e._listenId||(e._listenId=i.uniqueId(\"l\"));n[a]=e;if(!s&&typeof r===\"object\")s=this;e[t](r,s,this);return this}});u.bind=u.on;u.unbind=u.off;i.extend(e,u);var p=e.Model=function(t,e){var r=t||{};e||(e={});this.cid=i.uniqueId(\"c\");this.attributes={};if(e.collection)this.collection=e.collection;if(e.parse)r=this.parse(r,e)||{};r=i.defaults({},r,i.result(this,\"defaults\"));this.set(r,e);this.changed={};this.initialize.apply(this,arguments)};i.extend(p.prototype,u,{changed:null,validationError:null,idAttribute:\"id\",initialize:function(){},toJSON:function(t){return i.clone(this.attributes)},sync:function(){return e.sync.apply(this,arguments)},get:function(t){return this.attributes[t]},escape:function(t){return i.escape(this.get(t))},has:function(t){return this.get(t)!=null},set:function(t,e,r){var s,n,a,o,h,u,l,c;if(t==null)return this;if(typeof t===\"object\"){n=t;r=e}else{(n={})[t]=e}r||(r={});if(!this._validate(n,r))return false;a=r.unset;h=r.silent;o=[];u=this._changing;this._changing=true;if(!u){this._previousAttributes=i.clone(this.attributes);this.changed={}}c=this.attributes,l=this._previousAttributes;if(this.idAttribute in n)this.id=n[this.idAttribute];for(s in n){e=n[s];if(!i.isEqual(c[s],e))o.push(s);if(!i.isEqual(l[s],e)){this.changed[s]=e}else{delete this.changed[s]}a?delete c[s]:c[s]=e}if(!h){if(o.length)this._pending=r;for(var f=0,d=o.length;f<d;f++){this.trigger(\"change:\"+o[f],this,c[o[f]],r)}}if(u)return this;if(!h){while(this._pending){r=this._pending;this._pending=false;this.trigger(\"change\",this,r)}}this._pending=false;this._changing=false;return this},unset:function(t,e){return this.set(t,void 0,i.extend({},e,{unset:true}))},clear:function(t){var e={};for(var r in this.attributes)e[r]=void 0;return this.set(e,i.extend({},t,{unset:true}))},hasChanged:function(t){if(t==null)return!i.isEmpty(this.changed);return i.has(this.changed,t)},changedAttributes:function(t){if(!t)return this.hasChanged()?i.clone(this.changed):false;var e,r=false;var s=this._changing?this._previousAttributes:this.attributes;for(var n in t){if(i.isEqual(s[n],e=t[n]))continue;(r||(r={}))[n]=e}return r},previous:function(t){if(t==null||!this._previousAttributes)return null;return this._previousAttributes[t]},previousAttributes:function(){return i.clone(this._previousAttributes)},fetch:function(t){t=t?i.clone(t):{};if(t.parse===void 0)t.parse=true;var e=this;var r=t.success;t.success=function(i){if(!e.set(e.parse(i,t),t))return false;if(r)r(e,i,t);e.trigger(\"sync\",e,i,t)};q(this,t);return this.sync(\"read\",this,t)},save:function(t,e,r){var s,n,a,o=this.attributes;if(t==null||typeof t===\"object\"){s=t;r=e}else{(s={})[t]=e}r=i.extend({validate:true},r);if(s&&!r.wait){if(!this.set(s,r))return false}else{if(!this._validate(s,r))return false}if(s&&r.wait){this.attributes=i.extend({},o,s)}if(r.parse===void 0)r.parse=true;var h=this;var u=r.success;r.success=function(t){h.attributes=o;var e=h.parse(t,r);if(r.wait)e=i.extend(s||{},e);if(i.isObject(e)&&!h.set(e,r)){return false}if(u)u(h,t,r);h.trigger(\"sync\",h,t,r)};q(this,r);n=this.isNew()?\"create\":r.patch?\"patch\":\"update\";if(n===\"patch\")r.attrs=s;a=this.sync(n,this,r);if(s&&r.wait)this.attributes=o;return a},destroy:function(t){t=t?i.clone(t):{};var e=this;var r=t.success;var s=function(){e.trigger(\"destroy\",e,e.collection,t)};t.success=function(i){if(t.wait||e.isNew())s();if(r)r(e,i,t);if(!e.isNew())e.trigger(\"sync\",e,i,t)};if(this.isNew()){t.success();return false}q(this,t);var n=this.sync(\"delete\",this,t);if(!t.wait)s();return n},url:function(){var t=i.result(this,\"urlRoot\")||i.result(this.collection,\"url\")||M();if(this.isNew())return t;return t.replace(/([^\\/])$/,\"$1/\")+encodeURIComponent(this.id)},parse:function(t,e){return t},clone:function(){return new this.constructor(this.attributes)},isNew:function(){return!this.has(this.idAttribute)},isValid:function(t){return this._validate({},i.extend(t||{},{validate:true}))},_validate:function(t,e){if(!e.validate||!this.validate)return true;t=i.extend({},this.attributes,t);var r=this.validationError=this.validate(t,e)||null;if(!r)return true;this.trigger(\"invalid\",this,r,i.extend(e,{validationError:r}));return false}});var v=[\"keys\",\"values\",\"pairs\",\"invert\",\"pick\",\"omit\"];i.each(v,function(t){p.prototype[t]=function(){var e=o.call(arguments);e.unshift(this.attributes);return i[t].apply(i,e)}});var g=e.Collection=function(t,e){e||(e={});if(e.model)this.model=e.model;if(e.comparator!==void 0)this.comparator=e.comparator;this._reset();this.initialize.apply(this,arguments);if(t)this.reset(t,i.extend({silent:true},e))};var m={add:true,remove:true,merge:true};var y={add:true,remove:false};i.extend(g.prototype,u,{model:p,initialize:function(){},toJSON:function(t){return this.map(function(e){return e.toJSON(t)})},sync:function(){return e.sync.apply(this,arguments)},add:function(t,e){return this.set(t,i.extend({merge:false},e,y))},remove:function(t,e){var r=!i.isArray(t);t=r?[t]:i.clone(t);e||(e={});var s,n,a,o;for(s=0,n=t.length;s<n;s++){o=t[s]=this.get(t[s]);if(!o)continue;delete this._byId[o.id];delete this._byId[o.cid];a=this.indexOf(o);this.models.splice(a,1);this.length--;if(!e.silent){e.index=a;o.trigger(\"remove\",o,this,e)}this._removeReference(o,e)}return r?t[0]:t},set:function(t,e){e=i.defaults({},e,m);if(e.parse)t=this.parse(t,e);var r=!i.isArray(t);t=r?t?[t]:[]:i.clone(t);var s,n,a,o,h,u,l;var c=e.at;var f=this.model;var d=this.comparator&&c==null&&e.sort!==false;var v=i.isString(this.comparator)?this.comparator:null;var g=[],y=[],_={};var b=e.add,w=e.merge,x=e.remove;var E=!d&&b&&x?[]:false;for(s=0,n=t.length;s<n;s++){h=t[s]||{};if(h instanceof p){a=o=h}else{a=h[f.prototype.idAttribute||\"id\"]}if(u=this.get(a)){if(x)_[u.cid]=true;if(w){h=h===o?o.attributes:h;if(e.parse)h=u.parse(h,e);u.set(h,e);if(d&&!l&&u.hasChanged(v))l=true}t[s]=u}else if(b){o=t[s]=this._prepareModel(h,e);if(!o)continue;g.push(o);this._addReference(o,e)}o=u||o;if(E&&(o.isNew()||!_[o.id]))E.push(o);_[o.id]=true}if(x){for(s=0,n=this.length;s<n;++s){if(!_[(o=this.models[s]).cid])y.push(o)}if(y.length)this.remove(y,e)}if(g.length||E&&E.length){if(d)l=true;this.length+=g.length;if(c!=null){for(s=0,n=g.length;s<n;s++){this.models.splice(c+s,0,g[s])}}else{if(E)this.models.length=0;var k=E||g;for(s=0,n=k.length;s<n;s++){this.models.push(k[s])}}}if(l)this.sort({silent:true});if(!e.silent){for(s=0,n=g.length;s<n;s++){(o=g[s]).trigger(\"add\",o,this,e)}if(l||E&&E.length)this.trigger(\"sort\",this,e)}return r?t[0]:t},reset:function(t,e){e||(e={});for(var r=0,s=this.models.length;r<s;r++){this._removeReference(this.models[r],e)}e.previousModels=this.models;this._reset();t=this.add(t,i.extend({silent:true},e));if(!e.silent)this.trigger(\"reset\",this,e);return t},push:function(t,e){return this.add(t,i.extend({at:this.length},e))},pop:function(t){var e=this.at(this.length-1);this.remove(e,t);return e},unshift:function(t,e){return this.add(t,i.extend({at:0},e))},shift:function(t){var e=this.at(0);this.remove(e,t);return e},slice:function(){return o.apply(this.models,arguments)},get:function(t){if(t==null)return void 0;return this._byId[t]||this._byId[t.id]||this._byId[t.cid]},at:function(t){return this.models[t]},where:function(t,e){if(i.isEmpty(t))return e?void 0:[];return this[e?\"find\":\"filter\"](function(e){for(var i in t){if(t[i]!==e.get(i))return false}return true})},findWhere:function(t){return this.where(t,true)},sort:function(t){if(!this.comparator)throw new Error(\"Cannot sort a set without a comparator\");t||(t={});if(i.isString(this.comparator)||this.comparator.length===1){this.models=this.sortBy(this.comparator,this)}else{this.models.sort(i.bind(this.comparator,this))}if(!t.silent)this.trigger(\"sort\",this,t);return this},pluck:function(t){return i.invoke(this.models,\"get\",t)},fetch:function(t){t=t?i.clone(t):{};if(t.parse===void 0)t.parse=true;var e=t.success;var r=this;t.success=function(i){var s=t.reset?\"reset\":\"set\";r[s](i,t);if(e)e(r,i,t);r.trigger(\"sync\",r,i,t)};q(this,t);return this.sync(\"read\",this,t)},create:function(t,e){e=e?i.clone(e):{};if(!(t=this._prepareModel(t,e)))return false;if(!e.wait)this.add(t,e);var r=this;var s=e.success;e.success=function(t,i){if(e.wait)r.add(t,e);if(s)s(t,i,e)};t.save(null,e);return t},parse:function(t,e){return t},clone:function(){return new this.constructor(this.models)},_reset:function(){this.length=0;this.models=[];this._byId={}},_prepareModel:function(t,e){if(t instanceof p)return t;e=e?i.clone(e):{};e.collection=this;var r=new this.model(t,e);if(!r.validationError)return r;this.trigger(\"invalid\",this,r.validationError,e);return false},_addReference:function(t,e){this._byId[t.cid]=t;if(t.id!=null)this._byId[t.id]=t;if(!t.collection)t.collection=this;t.on(\"all\",this._onModelEvent,this)},_removeReference:function(t,e){if(this===t.collection)delete t.collection;t.off(\"all\",this._onModelEvent,this)},_onModelEvent:function(t,e,i,r){if((t===\"add\"||t===\"remove\")&&i!==this)return;if(t===\"destroy\")this.remove(e,r);if(e&&t===\"change:\"+e.idAttribute){delete this._byId[e.previous(e.idAttribute)];if(e.id!=null)this._byId[e.id]=e}this.trigger.apply(this,arguments)}});var _=[\"forEach\",\"each\",\"map\",\"collect\",\"reduce\",\"foldl\",\"inject\",\"reduceRight\",\"foldr\",\"find\",\"detect\",\"filter\",\"select\",\"reject\",\"every\",\"all\",\"some\",\"any\",\"include\",\"contains\",\"invoke\",\"max\",\"min\",\"toArray\",\"size\",\"first\",\"head\",\"take\",\"initial\",\"rest\",\"tail\",\"drop\",\"last\",\"without\",\"difference\",\"indexOf\",\"shuffle\",\"lastIndexOf\",\"isEmpty\",\"chain\",\"sample\"];i.each(_,function(t){g.prototype[t]=function(){var e=o.call(arguments);e.unshift(this.models);return i[t].apply(i,e)}});var b=[\"groupBy\",\"countBy\",\"sortBy\",\"indexBy\"];i.each(b,function(t){g.prototype[t]=function(e,r){var s=i.isFunction(e)?e:function(t){return t.get(e)};return i[t](this.models,s,r)}});var w=e.View=function(t){this.cid=i.uniqueId(\"view\");t||(t={});i.extend(this,i.pick(t,E));this._ensureElement();this.initialize.apply(this,arguments);this.delegateEvents()};var x=/^(\\S+)\\s*(.*)$/;var E=[\"model\",\"collection\",\"el\",\"id\",\"attributes\",\"className\",\"tagName\",\"events\"];i.extend(w.prototype,u,{tagName:\"div\",$:function(t){return this.$el.find(t)},initialize:function(){},render:function(){return this},remove:function(){this.$el.remove();this.stopListening();return this},setElement:function(t,i){if(this.$el)this.undelegateEvents();this.$el=t instanceof e.$?t:e.$(t);this.el=this.$el[0];if(i!==false)this.delegateEvents();return this},delegateEvents:function(t){if(!(t||(t=i.result(this,\"events\"))))return this;this.undelegateEvents();for(var e in t){var r=t[e];if(!i.isFunction(r))r=this[t[e]];if(!r)continue;var s=e.match(x);var n=s[1],a=s[2];r=i.bind(r,this);n+=\".delegateEvents\"+this.cid;if(a===\"\"){this.$el.on(n,r)}else{this.$el.on(n,a,r)}}return this},undelegateEvents:function(){this.$el.off(\".delegateEvents\"+this.cid);return this},_ensureElement:function(){if(!this.el){var t=i.extend({},i.result(this,\"attributes\"));if(this.id)t.id=i.result(this,\"id\");if(this.className)t[\"class\"]=i.result(this,\"className\");var r=e.$(\"<\"+i.result(this,\"tagName\")+\">\").attr(t);this.setElement(r,false)}else{this.setElement(i.result(this,\"el\"),false)}}});e.sync=function(t,r,s){var n=T[t];i.defaults(s||(s={}),{emulateHTTP:e.emulateHTTP,emulateJSON:e.emulateJSON});var a={type:n,dataType:\"json\"};if(!s.url){a.url=i.result(r,\"url\")||M()}if(s.data==null&&r&&(t===\"create\"||t===\"update\"||t===\"patch\")){a.contentType=\"application/json\";a.data=JSON.stringify(s.attrs||r.toJSON(s))}if(s.emulateJSON){a.contentType=\"application/x-www-form-urlencoded\";a.data=a.data?{model:a.data}:{}}if(s.emulateHTTP&&(n===\"PUT\"||n===\"DELETE\"||n===\"PATCH\")){a.type=\"POST\";if(s.emulateJSON)a.data._method=n;var o=s.beforeSend;s.beforeSend=function(t){t.setRequestHeader(\"X-HTTP-Method-Override\",n);if(o)return o.apply(this,arguments)}}if(a.type!==\"GET\"&&!s.emulateJSON){a.processData=false}if(a.type===\"PATCH\"&&k){a.xhr=function(){return new ActiveXObject(\"Microsoft.XMLHTTP\")}}var h=s.xhr=e.ajax(i.extend(a,s));r.trigger(\"request\",r,h,s);return h};var k=typeof window!==\"undefined\"&&!!window.ActiveXObject&&!(window.XMLHttpRequest&&(new XMLHttpRequest).dispatchEvent);var T={create:\"POST\",update:\"PUT\",patch:\"PATCH\",\"delete\":\"DELETE\",read:\"GET\"};e.ajax=function(){return e.$.ajax.apply(e.$,arguments)};var $=e.Router=function(t){t||(t={});if(t.routes)this.routes=t.routes;this._bindRoutes();this.initialize.apply(this,arguments)};var S=/\\((.*?)\\)/g;var H=/(\\(\\?)?:\\w+/g;var A=/\\*\\w+/g;var I=/[\\-{}\\[\\]+?.,\\\\\\^$|#\\s]/g;i.extend($.prototype,u,{initialize:function(){},route:function(t,r,s){if(!i.isRegExp(t))t=this._routeToRegExp(t);if(i.isFunction(r)){s=r;r=\"\"}if(!s)s=this[r];var n=this;e.history.route(t,function(i){var a=n._extractParameters(t,i);n.execute(s,a);n.trigger.apply(n,[\"route:\"+r].concat(a));n.trigger(\"route\",r,a);e.history.trigger(\"route\",n,r,a)});return this},execute:function(t,e){if(t)t.apply(this,e)},navigate:function(t,i){e.history.navigate(t,i);return this},_bindRoutes:function(){if(!this.routes)return;this.routes=i.result(this,\"routes\");var t,e=i.keys(this.routes);while((t=e.pop())!=null){this.route(t,this.routes[t])}},_routeToRegExp:function(t){t=t.replace(I,\"\\\\$&\").replace(S,\"(?:$1)?\").replace(H,function(t,e){return e?t:\"([^/?]+)\"}).replace(A,\"([^?]*?)\");return new RegExp(\"^\"+t+\"(?:\\\\?([\\\\s\\\\S]*))?$\")},_extractParameters:function(t,e){var r=t.exec(e).slice(1);return i.map(r,function(t,e){if(e===r.length-1)return t||null;return t?decodeURIComponent(t):null})}});var N=e.History=function(){this.handlers=[];i.bindAll(this,\"checkUrl\");if(typeof window!==\"undefined\"){this.location=window.location;this.history=window.history}};var R=/^[#\\/]|\\s+$/g;var O=/^\\/+|\\/+$/g;var P=/msie [\\w.]+/;var C=/\\/$/;var j=/#.*$/;N.started=false;i.extend(N.prototype,u,{interval:50,atRoot:function(){return this.location.pathname.replace(/[^\\/]$/,\"$&/\")===this.root},getHash:function(t){var e=(t||this).location.href.match(/#(.*)$/);return e?e[1]:\"\"},getFragment:function(t,e){if(t==null){if(this._hasPushState||!this._wantsHashChange||e){t=decodeURI(this.location.pathname+this.location.search);var i=this.root.replace(C,\"\");if(!t.indexOf(i))t=t.slice(i.length)}else{t=this.getHash()}}return t.replace(R,\"\")},start:function(t){if(N.started)throw new Error(\"Backbone.history has already been started\");N.started=true;this.options=i.extend({root:\"/\"},this.options,t);this.root=this.options.root;this._wantsHashChange=this.options.hashChange!==false;this._wantsPushState=!!this.options.pushState;this._hasPushState=!!(this.options.pushState&&this.history&&this.history.pushState);var r=this.getFragment();var s=document.documentMode;var n=P.exec(navigator.userAgent.toLowerCase())&&(!s||s<=7);this.root=(\"/\"+this.root+\"/\").replace(O,\"/\");if(n&&this._wantsHashChange){var a=e.$('<iframe src=\"javascript:0\" tabindex=\"-1\">');this.iframe=a.hide().appendTo(\"body\")[0].contentWindow;this.navigate(r)}if(this._hasPushState){e.$(window).on(\"popstate\",this.checkUrl)}else if(this._wantsHashChange&&\"onhashchange\"in window&&!n){e.$(window).on(\"hashchange\",this.checkUrl)}else if(this._wantsHashChange){this._checkUrlInterval=setInterval(this.checkUrl,this.interval)}this.fragment=r;var o=this.location;if(this._wantsHashChange&&this._wantsPushState){if(!this._hasPushState&&!this.atRoot()){this.fragment=this.getFragment(null,true);this.location.replace(this.root+\"#\"+this.fragment);return true}else if(this._hasPushState&&this.atRoot()&&o.hash){this.fragment=this.getHash().replace(R,\"\");this.history.replaceState({},document.title,this.root+this.fragment)}}if(!this.options.silent)return this.loadUrl()},stop:function(){e.$(window).off(\"popstate\",this.checkUrl).off(\"hashchange\",this.checkUrl);if(this._checkUrlInterval)clearInterval(this._checkUrlInterval);N.started=false},route:function(t,e){this.handlers.unshift({route:t,callback:e})},checkUrl:function(t){var e=this.getFragment();if(e===this.fragment&&this.iframe){e=this.getFragment(this.getHash(this.iframe))}if(e===this.fragment)return false;if(this.iframe)this.navigate(e);this.loadUrl()},loadUrl:function(t){t=this.fragment=this.getFragment(t);return i.any(this.handlers,function(e){if(e.route.test(t)){e.callback(t);return true}})},navigate:function(t,e){if(!N.started)return false;if(!e||e===true)e={trigger:!!e};var i=this.root+(t=this.getFragment(t||\"\"));t=t.replace(j,\"\");if(this.fragment===t)return;this.fragment=t;if(t===\"\"&&i!==\"/\")i=i.slice(0,-1);if(this._hasPushState){this.history[e.replace?\"replaceState\":\"pushState\"]({},document.title,i)}else if(this._wantsHashChange){this._updateHash(this.location,t,e.replace);if(this.iframe&&t!==this.getFragment(this.getHash(this.iframe))){if(!e.replace)this.iframe.document.open().close();this._updateHash(this.iframe.location,t,e.replace)}}else{return this.location.assign(i)}if(e.trigger)return this.loadUrl(t)},_updateHash:function(t,e,i){if(i){var r=t.href.replace(/(javascript:|#).*$/,\"\");t.replace(r+\"#\"+e)}else{t.hash=\"#\"+e}}});e.history=new N;var U=function(t,e){var r=this;var s;if(t&&i.has(t,\"constructor\")){s=t.constructor}else{s=function(){return r.apply(this,arguments)}}i.extend(s,r,e);var n=function(){this.constructor=s};n.prototype=r.prototype;s.prototype=new n;if(t)i.extend(s.prototype,t);s.__super__=r.prototype;return s};p.extend=g.extend=$.extend=w.extend=N.extend=U;var M=function(){throw new Error('A \"url\" property or function must be specified')};var q=function(t,e){var i=e.error;e.error=function(r){if(i)i(t,r,e);t.trigger(\"error\",t,r,e)}};return e});\n//# sourceMappingURL=backbone-min.map;\n",
    "define('plugin-annotations/annotations_module',['backbone'], function(Backbone) {\nvar EpubAnnotationsModule = function (contentDocumentDOM, bbPageSetView, annotationCSSUrl) {\n    \n    var EpubAnnotations = {};\n\n    // Rationale: The order of these matters\n    EpubAnnotations.TextLineInferrer = Backbone.Model.extend({\n\n    initialize : function (attributes, options) {},\n\n    // ----------------- PUBLIC INTERFACE --------------------------------------------------------------\n\n    inferLines : function (rectList) {\n\n        var inferredLines = [];\n        var numRects = rectList.length;\n        var numLines = 0;\n        var currLine;\n        var currRect;\n        var rectAppended;\n\n        // Iterate through each rect\n        for (var currRectNum = 0; currRectNum <= numRects - 1; currRectNum++) {\n            currRect = rectList[currRectNum];\n\n            // Check if the rect can be added to any of the current lines\n            rectAppended = false;\n            for (var currLineNum = 0; currLineNum <= numLines - 1; currLineNum++) {\n                currLine = inferredLines[currLineNum];\n\n                if (this.includeRectInLine(currLine, currRect.top, currRect.left, currRect.width, currRect.height)) {\n                    this.expandLine(currLine, currRect.left, currRect.top, currRect.width, currRect.height);\n                    rectAppended = true;\n                    break;   \n                }\n            } \n            \n            if (rectAppended) {\n                continue;\n            }\n            // If the rect can't be added to any existing lines, create a new line\n            else {\n                inferredLines.push(this.createNewLine(currRect.left, currRect.top, currRect.width, currRect.height));\n                numLines = numLines + 1; // Update the number of lines, so we're not using .length on every iteration\n            }\n        }\n\n        return inferredLines;\n    },\n\n\n    // ----------------- PRIVATE HELPERS ---------------------------------------------------------------\n\n    includeRectInLine : function (currLine, rectTop, rectLeft, rectWidth, rectHeight) {\n\n        // is on an existing line : based on vertical position\n        if (this.rectIsWithinLineVertically(rectTop, rectHeight, currLine.maxTop, currLine.maxBottom)) {\n            if (this.rectIsWithinLineHorizontally(rectLeft, rectWidth, currLine.left, currLine.width, currLine.avgHeight)) {\n                return true;\n            }\n        }\n\n        return false;\n    },\n\n    rectIsWithinLineVertically : function (rectTop, rectHeight, currLineMaxTop, currLineMaxBottom) {\n\n        var rectBottom = rectTop + rectHeight;\n        var lineHeight = currLineMaxBottom - currLineMaxTop;\n        var lineHeightAdjustment = (lineHeight * 0.75) / 2;\n        var rectHeightAdjustment = (rectHeight * 0.75) / 2;\n\n        rectTop = rectTop + rectHeightAdjustment;\n        rectBottom = rectBottom - rectHeightAdjustment;\n        currLineMaxTop = currLineMaxTop + lineHeightAdjustment;\n        currLineMaxBottom = currLineMaxBottom - lineHeightAdjustment;\n\n        if (rectTop === currLineMaxTop && rectBottom === currLineMaxBottom) {\n            return true;\n        }\n        else if (rectTop < currLineMaxTop && rectBottom < currLineMaxBottom && rectBottom > currLineMaxTop) {\n            return true;\n        }\n        else if (rectTop > currLineMaxTop && rectBottom > currLineMaxBottom && rectTop < currLineMaxBottom) {\n            return true;\n        }\n        else if (rectTop > currLineMaxTop && rectBottom < currLineMaxBottom) {\n            return true;\n        }\n        else if (rectTop < currLineMaxTop && rectBottom > currLineMaxBottom) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    },\n\n    rectIsWithinLineHorizontally : function (rectLeft, rectWidth, currLineLeft, currLineWidth, currLineAvgHeight) {\n\n        var lineGapHeuristic = 2 * currLineAvgHeight;\n        var rectRight = rectLeft + rectWidth;\n        var currLineRight = rectLeft + currLineWidth;\n\n        if ((currLineLeft - rectRight) > lineGapHeuristic) {\n            return false;\n        }\n        else if ((rectLeft - currLineRight) > lineGapHeuristic) {\n            return false;\n        }\n        else {\n            return true;\n        }\n    },\n\n    createNewLine : function (rectLeft, rectTop, rectWidth, rectHeight) {\n\n        var maxBottom = rectTop + rectHeight;\n\n        return {\n            left : rectLeft,\n            startTop : rectTop,\n            width : rectWidth, \n            avgHeight : rectHeight, \n            maxTop : rectTop,\n            maxBottom : maxBottom,\n            numRects : 1\n        };\n    },\n\n    expandLine : function (currLine, rectLeft, rectTop, rectWidth, rectHeight) {\n\n        var lineOldRight = currLine.left + currLine.width; \n\n        // Update all the properties of the current line with rect dimensions\n        var rectRight = rectLeft + rectWidth;\n        var rectBottom = rectTop + rectHeight;\n        var numRectsPlusOne = currLine.numRects + 1;\n\n        // Average height calculation\n        var currSumHeights = currLine.avgHeight * currLine.numRects;\n        var avgHeight = ((currSumHeights + rectHeight) / numRectsPlusOne);\n        currLine.avgHeight = avgHeight;\n        currLine.numRects = numRectsPlusOne;\n\n        // Expand the line vertically\n        currLine = this.expandLineVertically(currLine, rectTop, rectBottom);\n        currLine = this.expandLineHorizontally(currLine, rectLeft, rectRight);        \n\n        return currLine;\n    },\n\n    expandLineVertically : function (currLine, rectTop, rectBottom) {\n\n        if (rectTop < currLine.maxTop) {\n            currLine.maxTop = rectTop;\n        } \n        if (rectBottom > currLine.maxBottom) {\n            currLine.maxBottom = rectBottom;\n        }\n\n        return currLine;\n    },\n\n    expandLineHorizontally : function (currLine, rectLeft, rectRight) {\n\n        var newLineLeft = currLine.left <= rectLeft ? currLine.left : rectLeft;\n        var lineRight = currLine.left + currLine.width;\n        var newLineRight = lineRight >= rectRight ? lineRight : rectRight;\n        var newLineWidth = newLineRight - newLineLeft;\n        currLine.left = newLineLeft;\n        currLine.width = newLineWidth;\n\n        return currLine;\n    }\n});\n    EpubAnnotations.Highlight = Backbone.Model.extend({\n\n    defaults : {\n        \"isVisible\" : false\n    },\n\n    initialize : function (attributes, options) {}\n});\n    EpubAnnotations.HighlightGroup = Backbone.Model.extend({\n\n    defaults : function () {\n        return {\n            \"selectedNodes\" : [],\n            \"highlightViews\" : []\n        };\n    },\n\n    initialize : function (attributes, options) {\n        this.set(\"scale\", attributes.scale);\n        this.constructHighlightViews();\n    },\n\n    // --------------- PRIVATE HELPERS ---------------------------------------\n\n    highlightGroupCallback : function (event) {\n\n        var that = this;\n        \n        // Trigger this event on each of the highlight views (except triggering event)\n        if (event.type === \"click\") {\n            that.get(\"bbPageSetView\").trigger(\"annotationClicked\", \"highlight\", that.get(\"CFI\"), that.get(\"id\"), event);\n            return;\n        }\n\n\n        // Trigger this event on each of the highlight views (except triggering event)\n        if (event.type === \"contextmenu\") {\n            that.get(\"bbPageSetView\").trigger(\"annotationRightClicked\", \"highlight\", that.get(\"CFI\"), that.get(\"id\"), event);\n            return;\n        }\n\n\n        // Events that are called on each member of the group\n        _.each(this.get(\"highlightViews\"), function (highlightView) {\n\n            if (event.type === \"mouseenter\") {\n                highlightView.setHoverHighlight();    \n            }\n            else if (event.type === \"mouseleave\") {\n                highlightView.setBaseHighlight();\n            }\n        });\n    },\n\n    constructHighlightViews : function () {\n\n        var that = this;\n        var rectList = [];\n        var inferrer;\n        var inferredLines;\n\n        _.each(this.get(\"selectedNodes\"), function (node, index) {\n\n            var rects;\n            var range = document.createRange();\n            range.selectNodeContents(node);\n            rects = range.getClientRects();\n\n            // REFACTORING CANDIDATE: Maybe a better way to append an array here\n            _.each(rects, function (rect) {\n                rectList.push(rect);\n            });\n        });\n\n        inferrer = new EpubAnnotations.TextLineInferrer();\n        inferredLines = inferrer.inferLines(rectList);\n\n        var scale = this.get(\"scale\");\n\n        _.each(inferredLines, function (line, index) {\n\n            var highlightTop = line.startTop / scale;;\n            var highlightLeft = line.left / scale;;\n            var highlightHeight = line.avgHeight / scale;\n            var highlightWidth = line.width / scale;;\n\n            var highlightView = new EpubAnnotations.HighlightView({\n                CFI : that.get(\"CFI\"),\n                top : highlightTop + that.get(\"offsetTopAddition\"),\n                left : highlightLeft + that.get(\"offsetLeftAddition\"),\n                height : highlightHeight,\n                width : highlightWidth,\n                styles : that.get('styles'),\n                highlightGroupCallback : that.highlightGroupCallback,\n                callbackContext : that\n            });\n\n            that.get(\"highlightViews\").push(highlightView);\n        });\n    },\n\n    resetHighlights : function (viewportElement, offsetTop, offsetLeft) {\n\n        if (offsetTop) {\n            this.set({ offsetTopAddition : offsetTop });\n        }\n        if (offsetLeft) {\n            this.set({ offsetLeftAddition : offsetLeft });\n        }\n\n        this.destroyCurrentHighlights();\n        this.constructHighlightViews();\n        this.renderHighlights(viewportElement);\n    },\n\n    // REFACTORING CANDIDATE: Ensure that event listeners are being properly cleaned up. \n    destroyCurrentHighlights : function () { \n\n        _.each(this.get(\"highlightViews\"), function (highlightView) {\n            highlightView.remove();\n            highlightView.off();\n        });\n\n        this.get(\"highlightViews\").length = 0;\n    },\n\n    renderHighlights : function (viewportElement) {\n\n        _.each(this.get(\"highlightViews\"), function (view, index) {\n            $(viewportElement).append(view.render());\n        });\n    },\n\n    toInfo : function () {\n\n        return {\n\n            id : this.get(\"id\"),\n            type : \"highlight\",\n            CFI : this.get(\"CFI\")\n        };\n    },\n\n    setStyles : function (styles) {\n        var highlightViews = this.get('highlightViews');\n\n        this.set({styles : styles});\n\n        _.each(highlightViews, function(view, index) {\n            view.setStyles(styles);\n        });\n    }\n});\n\n    EpubAnnotations.Underline = Backbone.Model.extend({\n\n    defaults : {\n        \"isVisible\" : false\n    },\n\n    initialize : function (attributes, options) {}\n});\n    EpubAnnotations.UnderlineGroup = Backbone.Model.extend({\n\n    defaults : function () {\n        return {\n            \"selectedNodes\" : [],\n            \"underlineViews\" : []\n        };\n    },\n\n    initialize : function (attributes, options) {\n\n        this.constructUnderlineViews();\n    },\n\n    // --------------- PRIVATE HELPERS ---------------------------------------\n\n    underlineGroupCallback : function (event) {\n\n        var that = this;\n\n        // Trigger this event on each of the underline views (except triggering event)\n        if (event.type === \"click\") {\n            that.get(\"bbPageSetView\").trigger(\"annotationClicked\", \"underline\", that.get(\"CFI\"), that.get(\"id\"), event);\n            return;\n        }\n\n        // Events that are called on each member of the group\n        _.each(this.get(\"underlineViews\"), function (underlineView) {\n\n            if (event.type === \"mouseenter\") {\n                underlineView.setHoverUnderline();\n            }\n            else if (event.type === \"mouseleave\") {\n                underlineView.setBaseUnderline();\n            }\n        });\n    },\n\n    constructUnderlineViews : function () {\n\n        var that = this;\n        var rectList = [];\n        var inferrer;\n        var inferredLines;\n\n        _.each(this.get(\"selectedNodes\"), function (node, index) {\n\n            var rects;\n            var range = document.createRange();\n            range.selectNodeContents(node);\n            rects = range.getClientRects();\n\n            // REFACTORING CANDIDATE: Maybe a better way to append an array here\n            _.each(rects, function (rect) {\n                rectList.push(rect);\n            });\n        });\n\n        inferrer = new EpubAnnotations.TextLineInferrer();\n        inferredLines = inferrer.inferLines(rectList);\n\n        _.each(inferredLines, function (line, index) {\n\n            var underlineTop = line.startTop;\n            var underlineLeft = line.left;\n            var underlineHeight = line.avgHeight;\n            var underlineWidth = line.width;\n\n            var underlineView = new EpubAnnotations.UnderlineView({\n                CFI : that.get(\"CFI\"),\n                top : underlineTop + that.get(\"offsetTopAddition\"),\n                left : underlineLeft + that.get(\"offsetLeftAddition\"),\n                height : underlineHeight,\n                width : underlineWidth,\n                styles : that.get(\"styles\"),\n                underlineGroupCallback : that.underlineGroupCallback,\n                callbackContext : that\n            });\n\n            that.get(\"underlineViews\").push(underlineView);\n        });\n    },\n\n    resetUnderlines : function (viewportElement, offsetTop, offsetLeft) {\n\n        if (offsetTop) {\n            this.set({ offsetTopAddition : offsetTop });\n        }\n        if (offsetLeft) {\n            this.set({ offsetLeftAddition : offsetLeft });\n        }\n\n        this.destroyCurrentUnderlines();\n        this.constructUnderlineViews();\n        this.renderUnderlines(viewportElement);\n    },\n\n    // REFACTORING CANDIDATE: Ensure that event listeners are being properly cleaned up. \n    destroyCurrentUnderlines : function () { \n\n        _.each(this.get(\"underlineViews\"), function (underlineView) {\n            underlineView.remove();\n            underlineView.off();\n        });\n\n        this.get(\"underlineViews\").length = 0;\n    },\n\n    renderUnderlines : function (viewportElement) {\n\n        _.each(this.get(\"underlineViews\"), function (view, index) {\n            $(viewportElement).append(view.render());\n        });\n    },\n\n    toInfo : function () {\n\n        return {\n\n            id : this.get(\"id\"),\n            type : \"underline\",\n            CFI : this.get(\"CFI\")\n        };\n    },\n\n    setStyles : function (styles) {\n        \n        var underlineViews = this.get('underlineViews');\n\n        this.set({styles : styles});\n\n        _.each(underlineViews, function(view, index) {\n            view.setStyles(styles);\n        });\n    },\n});\n\n    EpubAnnotations.Bookmark = Backbone.Model.extend({\n\n    defaults : {\n        \"isVisible\" : false,\n        \"bookmarkCenteringAdjustment\" : 15,\n        \"bookmarkTopAdjustment\" : 45\n    },\n\n    initialize : function (attributes, options) {\n\n        // Figure out the top and left of the bookmark\n        // This should include the additional offset provided by the annotations object\n    },\n\n    getAbsoluteTop : function () {\n\n        var targetElementTop = $(this.get(\"targetElement\")).offset().top;\n        var bookmarkAbsoluteTop = this.get(\"offsetTopAddition\") + targetElementTop - this.get(\"bookmarkTopAdjustment\");\n        return bookmarkAbsoluteTop;\n    },\n\n    getAbsoluteLeft : function () {\n\n        var targetElementLeft = $(this.get(\"targetElement\")).offset().left;\n        var bookmarkAbsoluteLeft = this.get(\"offsetLeftAddition\") + targetElementLeft - this.get(\"bookmarkCenteringAdjustment\");\n        return bookmarkAbsoluteLeft;\n    },\n\n    toInfo : function () {\n\n        return {\n\n            id : this.get(\"id\"),\n            type : \"bookmark\",\n            CFI : this.get(\"CFI\")\n        };\n    }\n});\n    EpubAnnotations.ReflowableAnnotations = Backbone.Model.extend({\n\n    initialize : function (attributes, options) {\n        \n        this.epubCFI = EPUBcfi;\n        this.annotations = new EpubAnnotations.Annotations({\n            offsetTopAddition : 0, \n            offsetLeftAddition : 0, \n            readerBoundElement : $(\"html\", this.get(\"contentDocumentDOM\"))[0],\n            scale: 0,\n            bbPageSetView : this.get(\"bbPageSetView\")\n        });\n        // inject annotation CSS into iframe \n\n        \n        var annotationCSSUrl = this.get(\"annotationCSSUrl\");\n        if (annotationCSSUrl)\n        {\n            this.injectAnnotationCSS(annotationCSSUrl);\n        }\n\n        // emit an event when user selects some text.\n        var epubWindow = $(this.get(\"contentDocumentDOM\"));\n        var self = this;\n        epubWindow.on(\"mouseup\", function(event) {\n            var range = self.getCurrentSelectionRange();\n            if (range === undefined) {\n                return;\n            }\n            if (range.startOffset - range.endOffset) {\n                self.annotations.get(\"bbPageSetView\").trigger(\"textSelectionEvent\", event);\n            }\n        });\n\n\n    },\n\n    // ------------------------------------------------------------------------------------ //\n    //  \"PUBLIC\" METHODS (THE API)                                                          //\n    // ------------------------------------------------------------------------------------ //\n\n    redraw : function () {\n\n        var leftAddition = -this.getPaginationLeftOffset();\n        this.annotations.redrawAnnotations(0, leftAddition);\n    },\n\n   removeHighlight: function(annotationId) {\n        return this.annotations.removeHighlight(annotationId)\n    },\n\n\n\n    addHighlight : function (CFI, id, type, styles) {\n\n        var CFIRangeInfo;\n        var range;\n        var rangeStartNode;\n        var rangeEndNode;\n        var selectedElements;\n        var leftAddition;\n        var startMarkerHtml = this.getRangeStartMarker(CFI, id);\n        var endMarkerHtml = this.getRangeEndMarker(CFI, id);\n\n        // TODO webkit specific?\n        var $html = $(this.get(\"contentDocumentDOM\"));\n        var matrix = $('html', $html).css('-webkit-transform');\n        var scale = new WebKitCSSMatrix(matrix).a;\n        this.set(\"scale\", scale);\n\n        try {\n            CFIRangeInfo = this.epubCFI.injectRangeElements(\n                CFI,\n                this.get(\"contentDocumentDOM\"),\n                startMarkerHtml,\n                endMarkerHtml,\n                [\"cfi-marker\", \"mo-cfi-highlight\"],\n                [],\n                [\"MathJax_Message\"]\n                );\n\n            // Get start and end marker for the id, using injected into elements\n            // REFACTORING CANDIDATE: Abstract range creation to account for no previous/next sibling, for different types of\n            //   sibiling, etc. \n            rangeStartNode = CFIRangeInfo.startElement.nextSibling ? CFIRangeInfo.startElement.nextSibling : CFIRangeInfo.startElement;\n            rangeEndNode = CFIRangeInfo.endElement.previousSibling ? CFIRangeInfo.endElement.previousSibling : CFIRangeInfo.endElement;\n            range = document.createRange();\n            range.setStart(rangeStartNode, 0);\n            range.setEnd(rangeEndNode, rangeEndNode.length);\n\n            selectionInfo = this.getSelectionInfo(range);\n            leftAddition = -this.getPaginationLeftOffset();\n\n            if (type === \"highlight\") {\n                this.annotations.set('scale', this.get('scale'));\n                this.annotations.addHighlight(CFI, selectionInfo.selectedElements, id, 0, leftAddition, CFIRangeInfo.startElement, CFIRangeInfo.endElement, styles);\n            }\n            else if (type === \"underline\") {\n                this.annotations.addUnderline(CFI, selectionInfo.selectedElements, id, 0, leftAddition, styles);\n            }\n\n            return {\n                CFI : CFI, \n                selectedElements : selectionInfo.selectedElements\n            };\n\n        } catch (error) {\n            console.log(error.message);\n        }\n    },\n\n    addBookmark : function (CFI, id, type) {\n\n        var selectedElements;\n        var bookmarkMarkerHtml = this.getBookmarkMarker(CFI, id);\n        var $injectedElement;\n        var leftAddition;\n\n        try {\n            $injectedElement = this.epubCFI.injectElement(\n                CFI,\n                this.get(\"contentDocumentDOM\"),\n                bookmarkMarkerHtml,\n                [\"cfi-marker\", \"mo-cfi-highlight\"],\n                [],\n                [\"MathJax_Message\"]\n            );\n\n            // Add bookmark annotation here\n            leftAddition = -this.getPaginationLeftOffset();\n            this.annotations.addBookmark(CFI, $injectedElement[0], id, 0, leftAddition, type);\n\n            return {\n\n                CFI : CFI, \n                selectedElements : $injectedElement[0]\n            };\n\n        } catch (error) {\n            console.log(error.message);\n        }\n    },\n\n    addImageAnnotation : function (CFI, id) {\n\n        var selectedElements;\n        var bookmarkMarkerHtml = this.getBookmarkMarker(CFI, id);\n        var $targetImage;\n\n        try {\n            $targetImage = this.epubCFI.getTargetElement(\n                CFI,\n                this.get(\"contentDocumentDOM\"),\n                [\"cfi-marker\", \"mo-cfi-highlight\"],\n                [],\n                [\"MathJax_Message\"]\n            );\n            this.annotations.addImageAnnotation(CFI, $targetImage[0], id);\n\n            return {\n\n                CFI : CFI, \n                selectedElements : $targetImage[0]\n            };\n\n        } catch (error) {\n            console.log(error.message);\n        }\n    },\n\n    // this returns a partial CFI only!!\n    getCurrentSelectionCFI: function() {\n        var currentSelection = this.getCurrentSelectionRange();\n        var CFI;\n        if (currentSelection) {\n            selectionInfo = this.getSelectionInfo(currentSelection);\n            CFI = selectionInfo.CFI;\n        }\n\n        return CFI;\n    },\n\n    // this returns a partial CFI only!!\n    getCurrentSelectionOffsetCFI: function() {\n        var currentSelection = this.getCurrentSelectionRange();\n\n        var CFI;\n        if (currentSelection) {\n            CFI = this.generateCharOffsetCFI(currentSelection);\n        }\n        return CFI;\n    },\n\n\n    /// TODODM refactor thhis using getCurrentSelectionCFI (above)\n\n\n    addSelectionHighlight : function (id, type, styles) {\n\n        var arbitraryPackageDocCFI = \"/99!\"\n        var generatedContentDocCFI;\n        var CFI;\n        var selectionInfo;\n        var currentSelection = this.getCurrentSelectionRange();\n        var annotationInfo;\n\n        if (currentSelection) {\n\n            selectionInfo = this.getSelectionInfo(currentSelection);\n            generatedContentDocCFI = selectionInfo.CFI;\n            CFI = \"epubcfi(\" + arbitraryPackageDocCFI + generatedContentDocCFI + \")\";\n            if (type === \"highlight\") {\n                annotationInfo = this.addHighlight(CFI, id, type, styles);\n            }\n            else if (type === \"underline\") {\n                annotationInfo = this.addHighlight(CFI, id, type, styles);\n            }\n\n            // Rationale: The annotationInfo object returned from .addBookmark(...) contains the same value of \n            //   the CFI variable in the current scope. Since this CFI variable contains a \"hacked\" CFI value -\n            //   only the content document portion is valid - we want to replace the annotationInfo.CFI property with\n            //   the partial content document CFI portion we originally generated.\n            annotationInfo.CFI = generatedContentDocCFI;            \n            return annotationInfo;\n        }\n        else {\n            throw new Error(\"Nothing selected\");\n        }\n    },\n\n    addSelectionBookmark : function (id, type) {\n\n        var arbitraryPackageDocCFI = \"/99!\"\n        var generatedContentDocCFI;\n        var CFI;\n        var currentSelection = this.getCurrentSelectionRange();\n        var annotationInfo;\n\n        if (currentSelection) {\n\n            generatedContentDocCFI = this.generateCharOffsetCFI(currentSelection);\n            CFI = \"epubcfi(\" + arbitraryPackageDocCFI + generatedContentDocCFI + \")\";\n            annotationInfo = this.addBookmark(CFI, id, type);\n\n            // Rationale: The annotationInfo object returned from .addBookmark(...) contains the same value of \n            //   the CFI variable in the current scope. Since this CFI variable contains a \"hacked\" CFI value -\n            //   only the content document portion is valid - we want to replace the annotationInfo.CFI property with\n            //   the partial content document CFI portion we originally generated.\n            annotationInfo.CFI = generatedContentDocCFI;\n            return annotationInfo;\n        }\n        else {\n            throw new Error(\"Nothing selected\");\n        }\n    },\n\n    addSelectionImageAnnotation : function (id) {\n\n        var arbitraryPackageDocCFI = \"/99!\"\n        var generatedContentDocCFI;\n        var CFI;\n        var selectionInfo;\n        var currentSelection = this.getCurrentSelectionRange();\n        var annotationInfo;\n        var firstSelectedImage;\n\n        if (currentSelection) {\n\n            selectionInfo = this.getSelectionInfo(currentSelection, [\"img\"]);\n            firstSelectedImage = selectionInfo.selectedElements[0];\n            generatedContentDocCFI = this.epubCFI.generateElementCFIComponent(\n                firstSelectedImage,\n                [\"cfi-marker\", \"mo-cfi-highlight\"],\n                [],\n                [\"MathJax_Message\"]\n            );\n            CFI = \"epubcfi(\" + arbitraryPackageDocCFI + generatedContentDocCFI + \")\";\n            annotationInfo = this.addImageAnnotation(CFI, id);\n\n            // Rationale: The annotationInfo object returned from .addBookmark(...) contains the same value of \n            //   the CFI variable in the current scope. Since this CFI variable contains a \"hacked\" CFI value -\n            //   only the content document portion is valid - we want to replace the annotationInfo.CFI property with\n            //   the partial content document CFI portion we originally generated.\n            annotationInfo.CFI = generatedContentDocCFI;\n            return annotationInfo;\n        }\n        else {\n            throw new Error(\"Nothing selected\");\n        }\n    },\n\n    updateAnnotationView : function (id, styles) {\n\n        var annotationViews = this.annotations.updateAnnotationView(id, styles);\n\n        return annotationViews;\n    },\n\n    // ------------------------------------------------------------------------------------ //\n    //  \"PRIVATE\" HELPERS                                                                   //\n    // ------------------------------------------------------------------------------------ //\n\n    getSelectionInfo : function (selectedRange, elementType) {\n\n        // Generate CFI for selected text\n        var CFI = this.generateRangeCFI(selectedRange);\n        var intervalState = {\n            startElementFound : false,\n            endElementFound : false\n        };\n        var selectedElements = [];\n\n        if (!elementType) {\n            var elementType = [\"text\"];\n        }\n\n        this.findSelectedElements(\n            selectedRange.commonAncestorContainer, \n            selectedRange.startContainer, \n            selectedRange.endContainer,\n            intervalState,\n            selectedElements, \n            elementType\n        );\n\n        // Return a list of selected text nodes and the CFI\n        return {\n            CFI : CFI,\n            selectedElements : selectedElements\n        };\n    },\n\n    generateRangeCFI : function (selectedRange) {\n\n        var startNode = selectedRange.startContainer;\n        var endNode = selectedRange.endContainer;\n        var startOffset;\n        var endOffset;\n        var rangeCFIComponent;\n\n        if (startNode.nodeType === Node.TEXT_NODE && endNode.nodeType === Node.TEXT_NODE) {\n\n            startOffset = selectedRange.startOffset;\n            endOffset = selectedRange.endOffset;\n\n            rangeCFIComponent = this.epubCFI.generateCharOffsetRangeComponent(\n                startNode, \n                startOffset, \n                endNode, \n                endOffset,\n                [\"cfi-marker\", \"mo-cfi-highlight\"],\n                [],\n                [\"MathJax_Message\"]\n                );\n            return rangeCFIComponent;\n        }\n        else {\n            throw new Error(\"Selection start and end must be text nodes\");\n        }\n    },\n\n    generateCharOffsetCFI : function (selectedRange) {\n\n        // Character offset\n        var startNode = selectedRange.startContainer;\n        var startOffset = selectedRange.startOffset;\n        var charOffsetCFI;\n\n        if (startNode.nodeType === Node.TEXT_NODE) {\n            charOffsetCFI = this.epubCFI.generateCharacterOffsetCFIComponent(\n                startNode,\n                startOffset,\n                [\"cfi-marker\", \"mo-cfi-highlight\"],\n                [],\n                [\"MathJax_Message\"]\n            );\n        }\n        return charOffsetCFI;\n    },\n\n    // REFACTORING CANDIDATE: Convert this to jquery\n    findSelectedElements : function (currElement, startElement, endElement, intervalState, selectedElements, elementTypes) {\n\n        if (currElement === startElement) {\n            intervalState.startElementFound = true;\n        }\n\n        if (intervalState.startElementFound === true) {\n            this.addElement(currElement, selectedElements, elementTypes);\n        }\n\n        if (currElement === endElement) {\n            intervalState.endElementFound = true;\n            return;\n        }\n\n        if (currElement.firstChild) {\n            this.findSelectedElements(currElement.firstChild, startElement, endElement, intervalState, selectedElements, elementTypes);\n            if (intervalState.endElementFound) {\n                return;\n            }\n        }\n\n        if (currElement.nextSibling) {\n            this.findSelectedElements(currElement.nextSibling, startElement, endElement, intervalState, selectedElements, elementTypes);\n            if (intervalState.endElementFound) {\n                return;\n            }\n        }\n    },\n\n    addElement : function (currElement, selectedElements, elementTypes) {\n\n        // Check if the node is one of the types\n        _.each(elementTypes, function (elementType) {\n\n            if (elementType === \"text\") {\n                if (currElement.nodeType === Node.TEXT_NODE) {\n                    selectedElements.push(currElement);\n                }\n            }\n            else {\n                if ($(currElement).is(elementType)) {\n                    selectedElements.push(currElement);    \n                }\n            }\n        });\n    },\n\n    // Rationale: This is a cross-browser method to get the currently selected text\n    getCurrentSelectionRange : function () {\n\n        var currentSelection;\n        var iframeDocument = this.get(\"contentDocumentDOM\");\n        if (iframeDocument.getSelection) {\n            currentSelection = iframeDocument.getSelection();\n\n            if (currentSelection && currentSelection.rangeCount && (currentSelection.anchorOffset !== currentSelection.focusOffset)) {\n                return currentSelection.getRangeAt(0);\n            }else{\n                return undefined;\n            }\n        }\n        else if (iframeDocument.selection) {\n            return iframeDocument.selection.createRange();\n        }\n        else {\n            return undefined;\n        }\n    },\n\n    getPaginationLeftOffset : function () {\n\n        var $htmlElement = $(\"html\", this.get(\"contentDocumentDOM\"));\n        var offsetLeftPixels = $htmlElement.css(\"left\");\n        var offsetLeft = parseInt(offsetLeftPixels.replace(\"px\", \"\"));\n        return offsetLeft;\n    },\n\n    getBookmarkMarker : function (CFI, id) {\n\n        return \"<span class='bookmark-marker cfi-marker' id='\" + id + \"' data-cfi='\" + CFI + \"'></span>\";\n    },\n\n    getRangeStartMarker : function (CFI, id) {\n\n        return \"<span class='range-start-marker cfi-marker' id='start-\" + id + \"' data-cfi='\" + CFI + \"'></span>\";\n    },\n\n    getRangeEndMarker : function (CFI, id) {\n\n        return \"<span class='range-end-marker cfi-marker' id='end-\" + id + \"' data-cfi='\" + CFI + \"'></span>\";\n    },\n\n    injectAnnotationCSS : function (annotationCSSUrl) {\n\n        var $contentDocHead = $(\"head\", this.get(\"contentDocumentDOM\"));\n        $contentDocHead.append(\n            $(\"<link/>\", { rel : \"stylesheet\", href : annotationCSSUrl, type : \"text/css\" })\n        );\n    }\n});\n\n    EpubAnnotations.Annotations = Backbone.Model.extend({\n\n    defaults : function () {\n        return {\n            \"bookmarkViews\" : [],\n            \"highlights\" : [],\n            \"markers\"    : {},\n            \"underlines\" : [],\n            \"imageAnnotations\" : [],\n            \"annotationHash\" : {},\n            \"offsetTopAddition\" : 0,\n            \"offsetLeftAddition\" : 0,\n            \"readerBoundElement\" : undefined\n        };\n    },\n\n    initialize : function (attributes, options) {},\n\n\n    remove: function() {\n        var that = this;\n        _.each(this.get(\"highlights\"), function (highlightGroup) {\n            highlightGroup.remove();\n        });\n    },\n\n    redrawAnnotations : function (offsetTop, offsetLeft) {\n\n        var that = this;\n        // Highlights\n        _.each(this.get(\"highlights\"), function (highlightGroup) {\n            highlightGroup.resetHighlights(that.get(\"readerBoundElement\"), offsetTop, offsetLeft);\n        });\n\n        // Bookmarks\n        _.each(this.get(\"bookmarkViews\"), function (bookmarkView) {\n            bookmarkView.resetBookmark(offsetTop, offsetLeft);\n        });\n\n        // Underlines\n        _.each(this.get(\"underlines\"), function (underlineGroup) {\n            underlineGroup.resetUnderlines(that.get(\"readerBoundElement\"), offsetTop, offsetLeft);\n        });\n    },\n\n    getBookmark : function (id) {\n\n        var bookmarkView = this.get(\"annotationHash\")[id];\n        if (bookmarkView) {\n            return bookmarkView.bookmark.toInfo();\n        }\n        else {\n            return undefined;\n        }\n    },\n\n    getHighlight : function (id) {\n\n        var highlight = this.get(\"annotationHash\")[id];\n        if (highlight) {\n            return highlight.toInfo();\n        }\n        else {\n            return undefined;\n        }\n    },\n\n    getUnderline : function (id) {\n\n        var underline = this.get(\"annotationHash\")[id];\n        if (underline) {\n            return underline.toInfo();\n        }\n        else {\n            return undefined;\n        }\n    },\n\n    getBookmarks : function () {\n\n        var bookmarks = [];\n        _.each(this.get(\"bookmarkViews\"), function (bookmarkView) {\n\n            bookmarks.push(bookmarkView.bookmark.toInfo());\n        });\n        return bookmarks;\n    },\n\n    getHighlights : function () {\n\n        var highlights = [];\n        _.each(this.get(\"highlights\"), function (highlight) {\n\n            highlights.push(highlight.toInfo());\n        });\n        return highlights;\n    },\n\n    getUnderlines : function () {\n\n        var underlines = [];\n        _.each(this.get(\"underlines\"), function (underline) {\n\n            underlines.push(underline.toInfo());\n        });\n        return underlines;\n    },\n\n    getImageAnnotations : function () {\n\n        var imageAnnotations = [];\n        _.each(this.get(\"imageAnnotations\"), function (imageAnnotation) {\n\n            imageAnnotations.push(imageAnnotation.toInfo());\n        });\n        return imageAnnotations;\n    },\n\n    addBookmark : function (CFI, targetElement, annotationId, offsetTop, offsetLeft, type) {\n\n        if (!offsetTop) {\n            offsetTop = this.get(\"offsetTopAddition\");\n        }\n        if (!offsetLeft) {\n            offsetLeft = this.get(\"offsetLeftAddition\");\n        }\n\n        annotationId = annotationId.toString();\n        this.validateAnnotationId(annotationId);\n\n        var bookmarkView = new EpubAnnotations.BookmarkView({\n            CFI : CFI,\n            targetElement : targetElement, \n            offsetTopAddition : offsetTop,\n            offsetLeftAddition : offsetLeft,\n            id : annotationId.toString(),\n            bbPageSetView : this.get(\"bbPageSetView\"),\n            type : type\n        });\n        this.get(\"annotationHash\")[annotationId] = bookmarkView;\n        this.get(\"bookmarkViews\").push(bookmarkView);\n        $(this.get(\"readerBoundElement\")).append(bookmarkView.render());\n    },\n\n    removeHighlight: function(annotationId) {\n        var annotationHash = this.get(\"annotationHash\");\n        var highlights = this.get(\"highlights\");\n        var markers = this.get(\"markers\");\n\n        if (!markers[annotationId])\n            return;\n\n        var startMarker =  markers[annotationId].startMarker;\n        var endMarker = markers[annotationId].endMarker;\n\n        startMarker.parentNode.removeChild(startMarker);\n        endMarker.parentNode.removeChild(endMarker);\n\n        delete markers[annotationId];\n\n        delete annotationHash[annotationId];\n\n        highlights = _.reject(highlights, \n                              function(obj) { \n                                  if (obj.id == annotationId) {\n                                      obj.destroyCurrentHighlights();\n                                      return true;\n                                  } else {\n                                      return false;\n                                  }\n                              }\n                             );\n\n\n                             this.set(\"highlights\", highlights);\n    },\n\n    addHighlight : function (CFI, highlightedTextNodes, annotationId, offsetTop, offsetLeft, startMarker, endMarker, styles) {\n        if (!offsetTop) {\n            offsetTop = this.get(\"offsetTopAddition\");\n        }\n        if (!offsetLeft) {\n            offsetLeft = this.get(\"offsetLeftAddition\");\n        }\n\n        annotationId = annotationId.toString();\n        this.validateAnnotationId(annotationId);\n\n        var highlightGroup = new EpubAnnotations.HighlightGroup({\n            CFI : CFI,\n            selectedNodes : highlightedTextNodes,\n            offsetTopAddition : offsetTop,\n            offsetLeftAddition : offsetLeft,\n            styles: styles, \n            id : annotationId,\n            bbPageSetView : this.get(\"bbPageSetView\"),\n            scale: this.get(\"scale\")\n        });\n        this.get(\"annotationHash\")[annotationId] = highlightGroup;\n        this.get(\"highlights\").push(highlightGroup);\n        this.get(\"markers\")[annotationId] = {\"startMarker\": startMarker, \"endMarker\":endMarker};\n        highlightGroup.renderHighlights(this.get(\"readerBoundElement\"));\n    },\n\n    addUnderline : function (CFI, underlinedTextNodes, annotationId, offsetTop, offsetLeft, styles) {\n\n        if (!offsetTop) {\n            offsetTop = this.get(\"offsetTopAddition\");\n        }\n        if (!offsetLeft) {\n            offsetLeft = this.get(\"offsetLeftAddition\");\n        }\n\n        annotationId = annotationId.toString();\n        this.validateAnnotationId(annotationId);\n\n        var underlineGroup = new EpubAnnotations.UnderlineGroup({\n            CFI : CFI,\n            selectedNodes : underlinedTextNodes,\n            offsetTopAddition : offsetTop,\n            offsetLeftAddition : offsetLeft,\n            styles: styles,\n            id : annotationId,\n            bbPageSetView : this.get(\"bbPageSetView\")\n        });\n        this.get(\"annotationHash\")[annotationId] = underlineGroup;\n        this.get(\"underlines\").push(underlineGroup);\n        underlineGroup.renderUnderlines(this.get(\"readerBoundElement\"));\n    },\n\n    addImageAnnotation : function (CFI, imageNode, annotationId) {\n\n        annotationId = annotationId.toString();\n        this.validateAnnotationId(annotationId);\n\n        var imageAnnotation = new EpubAnnotations.ImageAnnotation({\n            CFI : CFI,\n            imageNode : imageNode,\n            id : annotationId,\n            bbPageSetView : this.get(\"bbPageSetView\")\n        });\n        this.get(\"annotationHash\")[annotationId] = imageAnnotation;\n        this.get(\"imageAnnotations\").push(imageAnnotation);\n        imageAnnotation.render();\n    },\n\n    updateAnnotationView : function (id, styles) {\n        var annotationViews = this.get(\"annotationHash\")[id];\n\n        annotationViews.setStyles(styles);\n\n        return annotationViews;\n    },\n\n    // REFACTORING CANDIDATE: Some kind of hash lookup would be more efficient here, might want to \n    //   change the implementation of the annotations as an array\n    validateAnnotationId : function (id) {\n\n        if (this.get(\"annotationHash\")[id]) {\n            throw new Error(\"That annotation id already exists; annotation not added\");\n        }\n    }\n});\n\n    EpubAnnotations.BookmarkView = Backbone.View.extend({\n\n    el : \"<div></div>\",\n\n    events : {\n        \"mouseenter\" : \"setHoverBookmark\",\n        \"mouseleave\" : \"setBaseBookmark\",\n        \"click\" : \"clickHandler\"\n    },\n\n    initialize : function (options) {\n\n        this.bookmark = new EpubAnnotations.Bookmark({\n            CFI : options.CFI,\n            targetElement : options.targetElement, \n            offsetTopAddition : options.offsetTopAddition,\n            offsetLeftAddition : options.offsetLeftAddition,\n            id : options.id,\n            bbPageSetView : options.bbPageSetView,\n            type : options.type\n        });\n    },\n\n    resetBookmark : function (offsetTop, offsetLeft) {\n\n        if (offsetTop) {\n            this.bookmark.set({ offsetTopAddition : offsetTop });\n        }\n\n        if (offsetLeft) {\n            this.bookmark.set({ offsetLeftAddition : offsetLeft });\n        }\n        this.setCSS();\n    },\n\n    render : function () {\n\n        this.setCSS();\n        return this.el;\n    },\n\n    setCSS : function () {\n\n        var absoluteTop;\n        var absoluteLeft;\n\n        if (this.bookmark.get(\"type\") === \"comment\") {\n            absoluteTop = this.bookmark.getAbsoluteTop();\n            absoluteLeft = this.bookmark.getAbsoluteLeft();\n            this.$el.css({ \n                \"top\" : absoluteTop + \"px\",\n                \"left\" : absoluteLeft + \"px\",\n                \"width\" : \"50px\",\n                \"height\" : \"50px\",\n                \"position\" : \"absolute\"\n            });\n            this.$el.addClass(\"comment\");\n        }\n        else {\n            this.$el.addClass(\"bookmark\");\n        }\n    },\n\n    setHoverBookmark : function (event) {\n\n        event.stopPropagation();\n        if (this.$el.hasClass(\"comment\")) {\n            this.$el.removeClass(\"comment\");\n            this.$el.addClass(\"hover-comment\");\n        }\n    },\n\n    setBaseBookmark : function (event) {\n\n        event.stopPropagation();\n        if (this.$el.hasClass(\"hover-comment\")) {\n            this.$el.removeClass(\"hover-comment\");\n            this.$el.addClass(\"comment\");\n        }\n    },\n\n    clickHandler : function (event) {\n\n        event.stopPropagation();\n        var type;\n        if (this.bookmark.get(\"type\") === \"comment\") {\n            type = \"comment\";\n        }\n        else {\n            type = \"bookmark\";\n        }\n\n        this.bookmark.get(\"bbPageSetView\").trigger(\"annotationClicked\", \n            type, \n            this.bookmark.get(\"CFI\"), \n            this.bookmark.get(\"id\"),\n            this.$el.css(\"top\"),\n            this.$el.css(\"left\"),\n            event\n        );\n    }\n});\n\n    EpubAnnotations.HighlightView = Backbone.View.extend({\n\n    el : \"<div class='highlight'></div>\",\n\n    events : {\n        \"mouseenter\" : \"highlightEvent\",\n        \"mouseleave\" : \"highlightEvent\",\n        \"click\" : \"highlightEvent\",\n        \"contextmenu\" : \"highlightEvent\"\n    },\n\n    initialize : function (options) {\n\n        this.highlight = new EpubAnnotations.Highlight({\n            CFI : options.CFI,\n            top : options.top,\n            left : options.left,\n            height : options.height,\n            width : options.width,\n            styles: options.styles,\n            highlightGroupCallback : options.highlightGroupCallback,\n            callbackContext : options.callbackContext\n        });\n    },\n\n    render : function () {\n\n        this.setCSS();\n        return this.el;\n    },\n\n    resetPosition : function (top, left, height, width) {\n\n        this.highlight.set({\n            top : top,\n            left : left,\n            height : height,\n            width : width\n        });\n        this.setCSS();\n    },\n\n    setStyles : function (styles) {\n\n        this.highlight.set({\n            styles : styles,\n        });\n        this.render();\n    },\n\n    setCSS : function () {\n\n        var styles = this.highlight.get(\"styles\") || {};\n        \n        this.$el.css({ \n            \"top\" : this.highlight.get(\"top\") + \"px\",\n            \"left\" : this.highlight.get(\"left\") + \"px\",\n            \"height\" : this.highlight.get(\"height\") + \"px\",\n            \"width\" : this.highlight.get(\"width\") + \"px\",\n            \"background-color\" : styles.fill_color || \"normal\",\n        });\n    },\n\n    setBaseHighlight : function () {\n\n        this.$el.addClass(\"highlight\");\n        this.$el.removeClass(\"hover-highlight\");\n    },\n\n    setHoverHighlight : function () {\n\n        this.$el.addClass(\"hover-highlight\");\n        this.$el.removeClass(\"highlight\");\n    },\n\n    highlightEvent : function (event) {\n\n        event.stopPropagation();\n        var highlightGroupCallback = this.highlight.get(\"highlightGroupCallback\");\n        var highlightGroupContext = this.highlight.get(\"callbackContext\");\n        highlightGroupContext.highlightGroupCallback(event);\n    }\n});\n\n    EpubAnnotations.UnderlineView = Backbone.View.extend({\n\n    el : \"<div class='underline-range'> \\\n             <div class='transparent-part'></div> \\\n             <div class='underline-part'></div> \\\n          </div>\",\n\n    events : {\n        \"mouseenter\" : \"underlineEvent\",\n        \"mouseleave\" : \"underlineEvent\",\n        \"click\" : \"underlineEvent\"\n    },\n\n    initialize : function (options) {\n\n        this.underline = new EpubAnnotations.Underline({\n            CFI : options.CFI,\n            top : options.top,\n            left : options.left,\n            height : options.height,\n            width : options.width,\n            styles : options.styles,\n            underlineGroupCallback : options.underlineGroupCallback,\n            callbackContext : options.callbackContext\n        });\n\n        this.$transparentElement = $(\".transparent-part\", this.$el);\n        this.$underlineElement = $(\".underline-part\", this.$el);\n    },\n\n    render : function () {\n\n        this.setCSS();\n        return this.el;\n    },\n\n    resetPosition : function (top, left, height, width) {\n\n        this.underline.set({\n            top : top,\n            left : left,\n            height : height,\n            width : width\n        });\n        this.setCSS();\n    },\n\n    setStyles : function (styles) {\n\n        this.underline.set({\n            styles : styles,\n        });\n        this.render();\n    },\n\n    setCSS : function () {\n        var styles = this.underline.get(\"styles\") || {};\n        \n        this.$el.css({ \n            \"top\" : this.underline.get(\"top\") + \"px\",\n            \"left\" : this.underline.get(\"left\") + \"px\",\n            \"height\" : this.underline.get(\"height\") + \"px\",\n            \"width\" : this.underline.get(\"width\") + \"px\",\n        });\n\n        // Underline part\n        this.$underlineElement.css({\n            \"background-color\" : styles.fill_color || \"normal\",\n        });\n\n        \n        this.$underlineElement.addClass(\"underline\");\n    },\n\n    underlineEvent : function (event) {\n\n        event.stopPropagation();\n        var underlineGroupCallback = this.underline.get(\"underlineGroupCallback\");\n        var underlineGroupContext = this.underline.get(\"callbackContext\");\n        underlineGroupContext.underlineGroupCallback(event);\n    },\n\n    setBaseUnderline : function () {\n\n        this.$underlineElement.addClass(\"underline\");\n        this.$underlineElement.removeClass(\"hover-underline\");\n    },\n\n    setHoverUnderline : function () {\n\n        this.$underlineElement.addClass(\"hover-underline\");\n        this.$underlineElement.removeClass(\"underline\");\n    },\n});\n\n    // Rationale: An image annotation does NOT have a view, as we don't know the state of an image element within an EPUB; it's entirely\n//   possible that an EPUB image element could have a backbone view associated with it already, which would cause problems if we \n//   tried to associate another backbone view. As such, this model modifies CSS properties for an annotated image element.\n//   \n//   An image annotation view that manages an absolutely position element (similar to bookmarks, underlines and highlights) can be\n//   added if more functionality is required. \n\nEpubAnnotations.ImageAnnotation = Backbone.Model.extend({\n\n    initialize : function (attributes, options) {\n\n        // Set handlers here. Can use jquery handlers\n        var that = this;\n        var $imageElement = $(this.get(\"imageNode\"));\n        $imageElement.on(\"mouseenter\", function () {\n            that.setMouseenterBorder();\n        });\n        $imageElement.on(\"mouseleave\", function () {\n            that.setMouseleaveBorder();\n        });\n        $imageElement.on(\"click\", function () {\n            that.get(\"bbPageSetView\").trigger(\"annotationClicked\", \"image\", that.get(\"CFI\"), that.get(\"id\"),event);\n        });\n    },\n\n    render : function () {\n\n        this.setCSS();\n    },\n\n    setCSS : function () {\n        \n        $(this.get(\"imageNode\")).css({\n            \"border\" : \"5px solid rgb(255, 0, 0)\",\n            \"border\" : \"5px solid rgba(255, 0, 0, 0.2)\",\n            \"-webkit-background-clip\" : \"padding-box\",\n            \"background-clip\" : \"padding-box\"\n        });\n    },\n\n    setMouseenterBorder : function () {\n\n        $(this.get(\"imageNode\")).css({\n            \"border\" : \"5px solid rgba(255, 0, 0, 0.4)\"\n        });\n    },\n\n    setMouseleaveBorder : function () {\n\n        $(this.get(\"imageNode\")).css({\n            \"border\" : \"5px solid rgba(255, 0, 0, 0.2)\"\n        });\n    }\n});\n\n\n\n    var reflowableAnnotations = new EpubAnnotations.ReflowableAnnotations({\n        contentDocumentDOM : contentDocumentDOM, \n        bbPageSetView : bbPageSetView,\n        annotationCSSUrl : annotationCSSUrl,\n    });\n\n    // Description: The public interface\n    return {\n\n        addSelectionHighlight : function (id, type, styles) { \n            return reflowableAnnotations.addSelectionHighlight(id, type, styles); \n        },\n        addSelectionBookmark : function (id, type) { \n            return reflowableAnnotations.addSelectionBookmark(id, type); \n        },\n        addSelectionImageAnnotation : function (id) {\n            return reflowableAnnotations.addSelectionImageAnnotation(id);\n        },\n        addHighlight : function (CFI, id, type, styles) { \n            return reflowableAnnotations.addHighlight(CFI, id, type, styles); \n        },\n        addBookmark : function (CFI, id, type) { \n            return reflowableAnnotations.addBookmark(CFI, id, type);\n        },\n        addImageAnnotation : function (CFI, id) { \n            return reflowableAnnotations.addImageAnnotation(CFI, id); \n        },\n        updateAnnotationView : function (id, styles) {\n            return reflowableAnnotations.updateAnnotationView(id, styles);\n        },\n        redraw : function () { \n            return reflowableAnnotations.redraw(); \n        },\n        getBookmark : function (id) { \n            return reflowableAnnotations.annotations.getBookmark(id); \n        },\n        getBookmarks : function () { \n            return reflowableAnnotations.annotations.getBookmarks(); \n        }, \n        getHighlight : function (id) { \n            return reflowableAnnotations.annotations.getHighlight(id); \n        },\n        getHighlights : function () { \n            return reflowableAnnotations.annotations.getHighlights(); \n        },\n        getUnderline : function (id) { \n            return reflowableAnnotations.annotations.getUnderline(id); \n        },\n        getUnderlines : function () { \n            return reflowableAnnotations.annotations.getUnderlines();\n        },\n        getImageAnnotation : function () {\n\n        },\n        getImageAnnotations : function () {\n\n        }, \n        removeAnnotation: function (annotationId) {\n            return reflowableAnnotations.remove(annotationId);\n        },\n        getCurrentSelectionCFI: function () {\n            return reflowableAnnotations.getCurrentSelectionCFI();\n        },\n        getCurrentSelectionOffsetCFI: function () {\n            return reflowableAnnotations.getCurrentSelectionOffsetCFI();\n        },\n        removeHighlight: function (annotationId) {\n            return reflowableAnnotations.removeHighlight(annotationId);\n        }\n    };\n};\n\n    return EpubAnnotationsModule;\n});\n",
    "//  Created by Dmitry Markushevich (dmitrym@evidentpoint.com)\n// \n//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\n//  \n//  Redistribution and use in source and binary forms, with or without modification, \n//  are permitted provided that the following conditions are met:\n//  1. Redistributions of source code must retain the above copyright notice, this \n//  list of conditions and the following disclaimer.\n//  2. Redistributions in binary form must reproduce the above copyright notice, \n//  this list of conditions and the following disclaimer in the documentation and/or \n//  other materials provided with the distribution.\n//  3. Neither the name of the organization nor the names of its contributors may be \n//  used to endorse or promote products derived from this software without specific \n//  prior written permission.\n//  \n//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND \n//  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED \n//  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. \n//  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, \n//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, \n//  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \n//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF \n//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE \n//  OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED \n//  OF THE POSSIBILITY OF SUCH DAMAGE.\n\n/*\n\n\n\n# Highlighting in Readium - A primer\n\nPlease note:\n\n- only simple text highlighting is currently supported\n- it's the job of the reading system to keep track of annotations. readium-js simply displays your annotations.\n- full CFIs for annotations are not currently available. We use so called \"partial CFI\"s, a tuple containing idref of the spine item and the CFI definition relative to the root of the spine item.\n\nCurrently, the API exposed via `ReaderView` exposes 4 functions and 1 even which should be sufficient for a simple highlighting workflow.\n\n\n# API\n\nFor the purposes of the examples below, `RReader` is a previously instantiated `ReaderView` instance.\n\n\n## Is anything selected (getCurrentSelectionCfi())\n\nBefore proceeding with the highlighting workflow it is sometimes necessary to determine whether the user has in fact selected anything. This can be accomplished with the following:\n\n\n\t> RReader.getCurrentSelectionCfi()\n\tObject {idref: \"id-id2604743\", cfi: \"/4/2/6,/1:74,/1:129\"}\n\nThe response contains a partial CFI that is sufficient to create a highlight based on selection. If nothing is selected *undefined* is returned. \n\nYou can also use partial Cfi with `openSpineItemElementCfi()` to navigate to where this selection is later.\n\n## Highlighting (addHighlight and addSelectionHighlight)\n\nOnce we've determined what needs to be highlighted (by generating a partial CFI from a selection, or having an existing partial CFI stored externally) we can add it to the reader by calling `addHighlight()`:\n\n\t> RReader.addHighlight('id-id2604743', \"/4/2/6,/1:74,/1:129\", 123, \"highlight\")\n\tObject {CFI: \"/4/2/6,/1:74,/1:129\", selectedElements: Array[1], idref: \"id-id2604743\"}\n\n*addHighligh*t takes the following parameters:\n\n- *id-id2604743* - `idref` is the idref value from `getCurrentSelectionCfi()\n- * /4/2/6,/1:74,/1:129* - `cfi` is the cfi value from `getCurrentSelectionCfi()\n- *123* - `id` is the unique id that defines this annotation\n- *highlight* - 'type' of annotation. only 'highlight' is currently supported.\n\n### addSelectioHighlight\n\nAlternatively, you can call addSelectionHighlight(). It combines both getCurrentSelectionCfi() and addHighlight into one call:\n\n\t> RReader.addSelectionHighlight(124, \"highlight\")\n\tObject {CFI: \"/4/2/4,/1:437,/1:503\", selectedElements: Array[1], idref: \"id-id2604743\"}\n\nNote that it provides no validation. If nothing is selected, `undefined` is returned.\n\n\n## Removing highlights \n\nTo remove the highlight, call `removeHighlight`:\n\n\t> RReader.removeHighlight(123)\n\tundefined\n\n\n# Handling annotation click events\n\nWhen a user clicks on a highlight `annotationClicked` event is dispatched with the following arguments:\n\n- type of annotation\n- idref of the spine item\n- partial Cfi of the annotation\n- annotationdId\n\n\n\t> RReader.on('annotationClicked', function(type, idref, cfi, annotationId) { console.log (type, idref, cfi, annotationId)});\n\tViews.ReaderView {on: function, once: function, off: function, trigger: function, listenTo: function???}\n\t\nThen when the user clicks on the highlight the following will show up in the console:\n\n\thighlight id-id2604743 /4/2/6,/1:74,/1:129 123 \n\t\n\n*/\ndefine('plugin-annotations/annotations_manager',['jquery', 'underscore', 'eventEmitter', './annotations_module'], function($, _, EventEmitter, EpubAnnotationsModule) {\n/**\n *\n * @param proxyObj\n * @param options\n * @constructor\n */\nvar AnnotationsManager = function (proxyObj, options) {\n\n    var self = this;\n    var liveAnnotations = {};\n    var spines = {};\n    var proxy = proxyObj; \n    var annotationCSSUrl = options.annotationCSSUrl;\n\n    if (!annotationCSSUrl) {\n        console.warn(\"WARNING! Annotations CSS not supplied. Highlighting is not going to work.\");\n    }\n\n    _.extend(this, new EventEmitter());\n\n    // we want to bubble up all of the events that annotations module may trigger up.\n    // this.on(\"all\", function() {\n    // });\n    //TODO: EventEmitter3 does not support \"all\" or \"*\" (catch-all event sink)\n    //https://github.com/primus/eventemitter3/blob/master/index.js#L61\n    //...so instead we patch trigger() and emit() (which are synonymous, see Bootstrapper.js EventEmitter.prototype.trigger = EventEmitter.prototype.emit;)\n        \n    var originalEmit = self['emit'];\n    \n    var triggerEmitPatch = function() {\n        var args = Array.prototype.slice.call(arguments);\nconsole.debug(args);\n\n        // mangle annotationClicked event. What really needs to happen is, the annotation_module needs to return a \n        // bare Cfi, and this class should append the idref.\n        var annotationClickedEvent = 'annotationClicked';\n        if (args.length && args[0] === annotationClickedEvent) {\n            for (var spineIndex in liveAnnotations)\n            {\n                var jQueryEvent = args[4];\n                var annotationId = args[3];\n                var fullFakeCfi = args[2];\n                var type = args[1];\n                if (liveAnnotations[spineIndex].getHighlight(annotationId)) {\n                    var idref = spines[spineIndex].idref;\n                    var partialCfi = getPartialCfi(fullFakeCfi);\n                    args = [annotationClickedEvent, type, idref, partialCfi, annotationId, jQueryEvent];\n                    \nconsole.debug(\"Corrected CFI:\");\nconsole.debug(args);\n                }\n            }\n        }\n        \n        originalEmit.apply(this, args);\n        originalEmit.apply(proxy, args);\n    };\n\n    this.trigger = triggerEmitPatch;\n    this.emit = triggerEmitPatch;\n\n    this.attachAnnotations = function($iframe, spineItem) {\n        var epubDocument = $iframe[0].contentDocument;\n        liveAnnotations[spineItem.index] = new EpubAnnotationsModule(epubDocument, self, annotationCSSUrl);\n        spines[spineItem.index] = spineItem;\n\n        // check to see which spine indecies can be culled depending on the distance from current spine item\n        for(var spineIndex in liveAnnotations) {\n            if (Math.abs(spineIndex - spineIndex.index) > 3) {\n                delete liveAnnotations[spineIndex];\n            }\n        }\n    };\n\n\n    this.getCurrentSelectionCfi = function() {\n        for(var spine in liveAnnotations) {\n            var annotationsForView = liveAnnotations[spine]; \n            var partialCfi = annotationsForView.getCurrentSelectionCFI();\n            if (partialCfi) {\n                return {\"idref\":spines[spine].idref, \"cfi\":partialCfi};\n            }\n        }\n        return undefined;\n    };\n\n    this.addSelectionHighlight = function(id, type) {\n        for(spine in liveAnnotations) {\n            var annotationsForView = liveAnnotations[spine]; \n            if (annotationsForView.getCurrentSelectionCFI()) {\n                var annotation = annotationsForView.addSelectionHighlight(id, type);\n                annotation.idref = spines[spine].idref;\n                return annotation;\n            }\n        }\n        return undefined;\n    };\n\n    this.addHighlight = function(spineIdRef, partialCfi, id, type, styles) {\n        for(var spine in liveAnnotations) {\n            if (spines[spine].idref === spineIdRef) {\n                var fakeCfi = \"epubcfi(/99!\" + partialCfi + \")\";\n                var annotationsForView = liveAnnotations[spine]; \n                var annotation = annotationsForView.addHighlight(fakeCfi, id, type, styles);\n                annotation.idref = spineIdRef;\n                annotation.CFI = getPartialCfi(annotation.CFI);\n                return annotation;\n            }\n        }\n        return undefined;\n    };\n\n    this.removeHighlight = function(id) {\n        var result = undefined;\n        for(var spine in liveAnnotations) {\n            var annotationsForView = liveAnnotations[spine]; \n            result  = annotationsForView.removeHighlight(id);\n        }\n        return result;\n    };\n\n\n\n    function getPartialCfi(CFI) {\n        var cfiWrapperPattern = new RegExp(\"^.*!\")\n        // remove epubcfi( and indirection step\n        var partiallyNakedCfi = CFI.replace(cfiWrapperPattern, \"\");\n        // remove last paren\n        var nakedCfi = partiallyNakedCfi.substring(0, partiallyNakedCfi.length -1);\n        return nakedCfi;\n    }\n\n\n};\n\nreturn AnnotationsManager;\n});\n",
    "define('plugin-annotations/main',['plugins-controller', './annotations_manager'], function (Plugins, AnnotationsManager) {\n    var config = {};\n\n    Plugins.register(\"annotations\", function (api) {\n        var _annotationsManager, _annotationsApi, _initialized = false, _initializedLate = false;\n\n        _annotationsApi = function () {\n            var self = this;\n\n            function isInitialized() {\n                if (!_initialized) {\n                    api.plugin.warn('Not initialized!')\n                }\n                return _initialized;\n            }\n\n            this.initialize = function (options) {\n                if (_initialized) {\n                    api.plugin.warn('Already initialized!');\n                    return;\n                }\n\n                _annotationsManager = new AnnotationsManager(self, options);\n\n                if (_initializedLate) {\n                    api.plugin.warn('Unable to attach to currently loaded content document.\\n' +\n                    'Initialize the plugin before loading a content document.');\n                }\n\n                _initialized = true;\n            };\n\n            /**\n             * Returns current selection partial Cfi, useful for workflows that need to check whether the user has selected something.\n             *\n             * @method getCurrentSelectionCfi\n             * @returns {object | undefined} partial cfi object or undefined if nothing is selected\n             *\n             */\n            this.getCurrentSelectionCfi = function () {\n                if (!isInitialized()) {\n                    return\n                }\n\n                return _annotationsManager.getCurrentSelectionCfi();\n            };\n\n            /**\n             * Creates a higlight based on given parameters\n             *\n             * @method addHighlight\n             * @param {string} spineIdRef spine idref that defines the partial Cfi\n             * @param {string} CFI partial CFI (withouth the indirection step) relative to the spine index\n             * @param {string} id id of the highlight. must be unique\n             * @param {string} type currently \"highlight\" only\n             *\n             * @returns {object | undefined} partial cfi object of the created highlight\n             *\n             */\n            this.addHighlight = function (spineIdRef, Cfi, id, type, styles) {\n                if (!isInitialized()) {\n                    return\n                }\n\n                return _annotationsManager.addHighlight(spineIdRef, Cfi, id, type, styles);\n            };\n\n\n            /**\n             * Creates a higlight based on current selection\n             *\n             * @method addSelectionHighlight\n             * @param {string} id id of the highlight. must be unique\n             * @param {string} type currently \"highlight\" only\n             *\n             * @returns {object | undefined} partial cfi object of the created highlight\n             *\n             */\n            this.addSelectionHighlight = function (id, type) {\n                if (!isInitialized()) {\n                    return\n                }\n\n                return _annotationsManager.addSelectionHighlight(id, type);\n            };\n\n            /**\n             * Removes given highlight\n             *\n             * @method removeHighlight\n             * @param {string} id id of the highlight.\n             *\n             * @returns {undefined}\n             *\n             */\n            this.removeHighlight = function (id) {\n                if (!isInitialized()) {\n                    return\n                }\n\n                return _annotationsManager.removeHighlight(id);\n            };\n\n        };\n\n\n        api.reader.on(ReadiumSDK.Events.CONTENT_DOCUMENT_LOADED, function ($iframe, spineItem) {\n            if (_initialized) {\n                _annotationsManager.attachAnnotations($iframe, spineItem);\n            } else {\n                _initializedLate = true;\n            }\n        });\n\n        // Extend the Reader API with the Annotations API under its own namespace\n        api.extendReader(new _annotationsApi());\n    });\n\n    return config;\n});\ndefine('plugin-annotations', ['plugin-annotations/main'], function (main) { return main; });\n\n",
    "//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\n//  \n//  Redistribution and use in source and binary forms, with or without modification, \n//  are permitted provided that the following conditions are met:\n//  1. Redistributions of source code must retain the above copyright notice, this \n//  list of conditions and the following disclaimer.\n//  2. Redistributions in binary form must reproduce the above copyright notice, \n//  this list of conditions and the following disclaimer in the documentation and/or \n//  other materials provided with the distribution.\n//  3. Neither the name of the organization nor the names of its contributors may be \n//  used to endorse or promote products derived from this software without specific \n//  prior written permission.\n\ndefine('readium-plugin-annotations',['plugin-annotations'], function (pluginAnnotationsConfig) {\nreturn pluginAnnotationsConfig;\n});\n\n"
  ]
}